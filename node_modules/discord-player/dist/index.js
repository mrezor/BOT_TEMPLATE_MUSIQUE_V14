"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AF_NIGHTCORE_RATE: () => import_equalizer3.AF_NIGHTCORE_RATE,
  AF_VAPORWAVE_RATE: () => import_equalizer3.AF_VAPORWAVE_RATE,
  AFilterGraph: () => AFilterGraph,
  AudioFilters: () => AudioFilters,
  BASS_EQ_BANDS: () => import_equalizer3.BASS_EQ_BANDS,
  BaseExtractor: () => BaseExtractor,
  BiquadFilterType: () => import_equalizer3.FilterType,
  DiscordPlayerQueryResultCache: () => DiscordPlayerQueryResultCache,
  EqualizerConfigurationPreset: () => EqualizerConfigurationPreset,
  ErrorStatusCode: () => ErrorStatusCode,
  ExtractorExecutionContext: () => ExtractorExecutionContext,
  FFMPEG_ARGS_PIPED: () => FFMPEG_ARGS_PIPED,
  FFMPEG_ARGS_STRING: () => FFMPEG_ARGS_STRING,
  FFMPEG_SRATE_REGEX: () => FFMPEG_SRATE_REGEX,
  FFmpegFilterer: () => FFmpegFilterer,
  FiltersChain: () => import_equalizer3.FiltersChain,
  GuildNodeManager: () => GuildNodeManager,
  GuildQueue: () => GuildQueue,
  GuildQueueAudioFilters: () => GuildQueueAudioFilters,
  GuildQueueEvent: () => GuildQueueEvent,
  GuildQueueHistory: () => GuildQueueHistory,
  GuildQueuePlayerNode: () => GuildQueuePlayerNode,
  PCMAudioFilters: () => import_equalizer3.AudioFilters,
  Player: () => Player,
  PlayerError: () => PlayerError,
  PlayerEvent: () => PlayerEvent,
  PlayerEventsEmitter: () => PlayerEventsEmitter,
  Playlist: () => Playlist,
  Q_BUTTERWORTH: () => import_equalizer3.Q_BUTTERWORTH,
  QueryCache: () => QueryCache,
  QueryResolver: () => QueryResolver,
  QueryType: () => QueryType,
  QueueRepeatMode: () => QueueRepeatMode,
  SearchResult: () => SearchResult,
  StreamDispatcher: () => StreamDispatcher,
  Track: () => Track,
  TypeUtil: () => TypeUtil,
  Util: () => Util,
  VoiceReceiverNode: () => VoiceReceiverNode,
  VoiceUtils: () => VoiceUtils,
  VolumeTransformer: () => import_equalizer3.VolumeTransformer,
  createFFmpegStream: () => createFFmpegStream,
  onAfterCreateStream: () => onAfterCreateStream,
  onBeforeCreateStream: () => onBeforeCreateStream,
  useHistory: () => useHistory,
  useMasterPlayer: () => useMasterPlayer,
  useMetadata: () => useMetadata,
  usePlayer: () => usePlayer,
  useQueue: () => useQueue,
  useTimeline: () => useTimeline,
  version: () => version2
});
module.exports = __toCommonJS(src_exports);
var import_discord4 = require("discord.js");

// src/utils/PlayerEventsEmitter.ts
var import_utils = require("@discord-player/utils");

// src/utils/Util.ts
var import_promises = require("timers/promises");
var Util = class {
  constructor() {
  }
  static durationString(durObj) {
    return Object.values(durObj).map((m) => isNaN(m) ? 0 : m).join(":");
  }
  static parseMS(milliseconds) {
    if (isNaN(milliseconds))
      milliseconds = 0;
    const round = milliseconds > 0 ? Math.floor : Math.ceil;
    return {
      days: round(milliseconds / 864e5),
      hours: round(milliseconds / 36e5) % 24,
      minutes: round(milliseconds / 6e4) % 60,
      seconds: round(milliseconds / 1e3) % 60
    };
  }
  static buildTimeCode(duration) {
    const items = Object.keys(duration);
    const required = ["days", "hours", "minutes", "seconds"];
    const parsed = items.filter((x) => required.includes(x)).map((m) => duration[m]);
    const final = parsed.slice(parsed.findIndex((x) => x !== 0)).map((x) => x.toString().padStart(2, "0")).join(":");
    return final.length <= 3 ? `0:${final.padStart(2, "0") || 0}` : final;
  }
  static last(arr) {
    if (!Array.isArray(arr))
      return arr;
    return arr[arr.length - 1];
  }
  static isVoiceEmpty(channel) {
    return channel && channel.members.filter((member) => !member.user.bot).size === 0;
  }
  static require(id) {
    try {
      return { module: require(id), error: null };
    } catch (error) {
      return { module: null, error };
    }
  }
  static async import(id) {
    try {
      const mod = await import(id);
      return { module: mod, error: null };
    } catch (error) {
      return { module: null, error };
    }
  }
  static wait(time) {
    return (0, import_promises.setTimeout)(time, void 0, { ref: false });
  }
  static noop() {
  }
  static async getFetch() {
    if ("fetch" in globalThis)
      return globalThis.fetch;
    for (const lib of ["node-fetch", "undici"]) {
      try {
        return await import(lib).then((res) => res.fetch || res.default?.fetch || res.default);
      } catch {
        try {
          const res = require(lib);
          if (res)
            return res.fetch || res.default?.fetch || res.default;
        } catch {
        }
      }
    }
  }
  static warn(message, code = "DeprecationWarning", detail) {
    process.emitWarning(message, {
      code,
      detail
    });
  }
  static randomChoice(src) {
    return src[Math.floor(Math.random() * src.length)];
  }
};
__name(Util, "Util");

// src/utils/PlayerEventsEmitter.ts
var PlayerEventsEmitter = class extends import_utils.EventEmitter {
  constructor(requiredEvents = []) {
    super();
    this.requiredEvents = requiredEvents;
  }
  emit(name, ...args) {
    if (this.requiredEvents.includes(name) && !this.eventNames().includes(name)) {
      console.error(...args);
      Util.warn(
        `No event listener found for event "${String(name)}". Events ${this.requiredEvents.map((m) => `"${String(m)}"`).join(", ")} must have event listeners.`,
        "UnhandledEventsWarning"
      );
      return false;
    }
    return super.emit(name, ...args);
  }
};
__name(PlayerEventsEmitter, "PlayerEventsEmitter");

// src/utils/AudioFilters.ts
var bass = /* @__PURE__ */ __name((g) => `bass=g=${g}:f=110:w=0.3`, "bass");
var _AudioFilters = class {
  constructor() {
    return _AudioFilters;
  }
  static get(name) {
    return this.filters[name];
  }
  static has(name) {
    return name in this.filters;
  }
  static *[Symbol.iterator]() {
    for (const [k, v] of Object.entries(this.filters)) {
      yield { name: k, value: v };
    }
  }
  static get names() {
    return Object.keys(this.filters);
  }
  static get length() {
    return this.names.length;
  }
  static toString() {
    return this.names.map((m) => this[m]).join(",");
  }
  static create(filters) {
    if (!filters || !Array.isArray(filters))
      return this.toString();
    return filters.filter((predicate) => typeof predicate === "string").map((m) => this.get(m)).join(",");
  }
  static define(filterName, value) {
    this.filters[filterName] = value;
  }
  static defineBulk(filtersArray) {
    filtersArray.forEach((arr) => this.define(arr.name, arr.value));
  }
};
var AudioFilters = _AudioFilters;
__name(AudioFilters, "AudioFilters");
AudioFilters.filters = {
  bassboost_low: bass(15),
  bassboost: bass(20),
  bassboost_high: bass(30),
  "8D": "apulsator=hz=0.09",
  vaporwave: "aresample=48000,asetrate=48000*0.8",
  nightcore: "aresample=48000,asetrate=48000*1.25",
  lofi: "aresample=48000,asetrate=48000*0.9,extrastereo=m=2.5:c=disabled",
  phaser: "aphaser=in_gain=0.4",
  tremolo: "tremolo",
  vibrato: "vibrato=f=6.5",
  reverse: "areverse",
  treble: "treble=g=5",
  normalizer2: "dynaudnorm=g=101",
  normalizer: "acompressor",
  surrounding: "surround",
  pulsator: "apulsator=hz=1",
  subboost: "asubboost",
  karaoke: "stereotools=mlev=0.03",
  flanger: "flanger",
  gate: "agate",
  haas: "haas",
  mcompand: "mcompand",
  mono: "pan=mono|c0=.5*c0+.5*c1",
  mstlr: "stereotools=mode=ms>lr",
  mstrr: "stereotools=mode=ms>rr",
  compressor: "compand=points=-80/-105|-62/-80|-15.4/-15.4|0/-12|20/-7.6",
  expander: "compand=attacks=0:points=-80/-169|-54/-80|-49.5/-64.6|-41.1/-41.1|-25.8/-15|-10.8/-4.5|0/0|20/8.3",
  softlimiter: "compand=attacks=0:points=-80/-80|-12.4/-12.4|-6/-8|0/-6.8|20/-2.8",
  chorus: "chorus=0.7:0.9:55:0.4:0.25:2",
  chorus2d: "chorus=0.6:0.9:50|60:0.4|0.32:0.25|0.4:2|1.3",
  chorus3d: "chorus=0.5:0.9:50|60|40:0.4|0.32|0.3:0.25|0.4|0.3:2|2.3|1.3",
  fadein: "afade=t=in:ss=0:d=10",
  dim: `afftfilt="'real=re * (1-clip((b/nb)*b,0,1))':imag='im * (1-clip((b/nb)*b,0,1))'"`,
  earrape: "channelsplit,sidechaingate=level_in=64"
};
var AudioFilters_default = AudioFilters;

// src/extractors/BaseExtractor.ts
var BaseExtractor = class {
  constructor(context, options = {}) {
    this.context = context;
    this.options = options;
  }
  get identifier() {
    return this.constructor.identifier;
  }
  async activate() {
    return;
  }
  async deactivate() {
    return;
  }
  async validate(query, type) {
    return false;
  }
  async stream(info) {
    throw new Error("Not Implemented");
  }
  async handle(query, context) {
    throw new Error("Not Implemented");
  }
  async getRelatedTracks(track) {
    throw new Error("Not implemented");
  }
  handlePostStream(stream, next) {
    return next(null, stream);
  }
  emit(event, ...args) {
    return this.context.player.emit(event, ...args);
  }
  createResponse(playlist, tracks = playlist?.tracks || []) {
    return { playlist: playlist || null, tracks };
  }
  debug(message) {
    return this.context.player.debug(message);
  }
};
__name(BaseExtractor, "BaseExtractor");
BaseExtractor.identifier = "com.discord-player.extractor";

// src/extractors/ExtractorExecutionContext.ts
var import_utils2 = require("@discord-player/utils");
var knownExtractorKeys = [
  "SpotifyExtractor",
  "AppleMusicExtractor",
  "SoundCloudExtractor",
  "YouTubeExtractor",
  "VimeoExtractor",
  "ReverbnationExtractor",
  "AttachmentExtractor"
];
var knownExtractorLib = "@discord-player/extractor";
var ExtractorExecutionContext = class extends PlayerEventsEmitter {
  constructor(player) {
    super(["error"]);
    this.player = player;
    this.store = new import_utils2.Collection();
  }
  async loadDefault() {
    const mod = await Util.import(knownExtractorLib);
    if (mod.error)
      return { success: false, error: mod.error };
    knownExtractorKeys.forEach((key) => {
      if (!mod.module[key])
        return;
      this.register(mod.module[key]);
    });
    return { success: true, error: null };
  }
  isRegistered(identifier) {
    return this.store.has(identifier);
  }
  get size() {
    return this.store.size;
  }
  get(identifier) {
    return this.store.get(identifier);
  }
  async register(_extractor, options = {}) {
    if (typeof _extractor.identifier !== "string" || this.store.has(_extractor.identifier))
      return;
    const extractor = new _extractor(this, options);
    try {
      this.store.set(_extractor.identifier, extractor);
      this.player.debug(`${_extractor.identifier} extractor loaded!`);
      this.emit("registered", this, extractor);
      await extractor.activate();
      this.player.debug(`${_extractor.identifier} extractor activated!`);
      this.emit("activate", this, extractor);
    } catch (e) {
      this.store.delete(_extractor.identifier);
      this.player.debug(`${_extractor.identifier} extractor failed to activate! Error: ${e}`);
      this.emit("error", this, extractor, e);
    }
  }
  async unregister(_extractor) {
    const extractor = typeof _extractor === "string" ? this.store.get(_extractor) : this.store.find((r) => r === _extractor);
    if (!extractor)
      return;
    try {
      const key = extractor.identifier || this.store.findKey((e) => e === extractor);
      this.store.delete(key);
      this.player.debug(`${extractor.identifier} extractor disabled!`);
      this.emit("unregistered", this, extractor);
      await extractor.deactivate();
      this.player.debug(`${extractor.identifier} extractor deactivated!`);
      this.emit("deactivate", this, extractor);
    } catch (e) {
      this.player.debug(`${extractor.identifier} extractor failed to deactivate!`);
      this.emit("error", this, extractor, e);
    }
  }
  async unregisterAll() {
    try {
      await Promise.all(this.store.map((e) => this.unregister(e)));
    } catch {
    }
  }
  async run(fn, filterBlocked = true) {
    const blocked = this.player.options.blockExtractors ?? [];
    for (const ext of this.store.values()) {
      if (filterBlocked && blocked.some((e) => e === ext.identifier))
        continue;
      this.player.debug(`Executing extractor ${ext.identifier}...`);
      const result = await fn(ext).catch((e) => {
        this.player.debug(`Extractor ${ext.identifier} failed with error: ${e}`);
        return false;
      });
      if (result) {
        this.player.debug(`Extractor ${ext.identifier} executed successfully!`);
        return {
          extractor: ext,
          result
        };
      }
    }
    return null;
  }
};
__name(ExtractorExecutionContext, "ExtractorExecutionContext");

// src/Structures/GuildNodeManager.ts
var import_utils6 = require("@discord-player/utils");

// src/Structures/GuildQueue.ts
var import_discord2 = require("discord.js");
var import_utils4 = require("@discord-player/utils");
var import_voice2 = require("@discordjs/voice");

// src/Structures/Playlist.ts
var Playlist = class {
  constructor(player, data) {
    this.player = player;
    this.tracks = data.tracks ?? [];
    this.author = data.author;
    this.description = data.description;
    this.thumbnail = data.thumbnail;
    this.type = data.type;
    this.source = data.source;
    this.id = data.id;
    this.url = data.url;
    this.title = data.title;
  }
  *[Symbol.iterator]() {
    yield* this.tracks;
  }
  get estimatedDuration() {
    return this.tracks.reduce((p, c) => p + c.durationMS, 0);
  }
  get durationFormatted() {
    return Util.buildTimeCode(Util.parseMS(this.estimatedDuration));
  }
  toJSON(withTracks = true) {
    const payload = {
      id: this.id,
      url: this.url,
      title: this.title,
      description: this.description,
      thumbnail: this.thumbnail,
      type: this.type,
      source: this.source,
      author: this.author,
      tracks: []
    };
    if (withTracks)
      payload.tracks = this.tracks.map((m) => m.toJSON(true));
    return payload;
  }
};
__name(Playlist, "Playlist");

// src/Structures/GuildQueueHistory.ts
var import_utils3 = require("@discord-player/utils");
var GuildQueueHistory = class {
  constructor(queue) {
    this.queue = queue;
    this.tracks = new import_utils3.Queue("LIFO");
  }
  get currentTrack() {
    return this.queue.dispatcher?.audioResource?.metadata || this.queue.__current;
  }
  get nextTrack() {
    return this.queue.tracks.at(0) || null;
  }
  get previousTrack() {
    return this.tracks.at(0) || null;
  }
  get disabled() {
    return this.queue.options.disableHistory;
  }
  get size() {
    return this.tracks.size;
  }
  getSize() {
    return this.size;
  }
  isEmpty() {
    return this.tracks.size < 1;
  }
  push(track) {
    if (this.disabled)
      return false;
    this.tracks.add(track);
    return true;
  }
  clear() {
    this.tracks.clear();
  }
  async next() {
    const track = this.nextTrack;
    if (!track) {
      throw new Error("No next track in the queue");
    }
    this.queue.node.skip();
  }
  async previous(preserveCurrent = true) {
    const track = this.tracks.dispatch();
    if (!track) {
      throw new Error("No previous track in the queue");
    }
    const current = this.currentTrack;
    await this.queue.node.play(track, { queue: false });
    if (current && preserveCurrent)
      this.queue.node.insert(current, 0);
  }
  back() {
    return this.previous();
  }
};
__name(GuildQueueHistory, "GuildQueueHistory");

// src/Structures/GuildQueuePlayerNode.ts
var import_voice = require("@discordjs/voice");

// src/utils/QueryResolver.ts
var import_youtube_sr = require("youtube-sr");

// src/types/types.ts
var QueryType = {
  AUTO: "auto",
  YOUTUBE: "youtube",
  YOUTUBE_PLAYLIST: "youtubePlaylist",
  SOUNDCLOUD_TRACK: "soundcloudTrack",
  SOUNDCLOUD_PLAYLIST: "soundcloudPlaylist",
  SOUNDCLOUD: "soundcloud",
  SPOTIFY_SONG: "spotifySong",
  SPOTIFY_ALBUM: "spotifyAlbum",
  SPOTIFY_PLAYLIST: "spotifyPlaylist",
  SPOTIFY_SEARCH: "spotifySearch",
  FACEBOOK: "facebook",
  VIMEO: "vimeo",
  ARBITRARY: "arbitrary",
  REVERBNATION: "reverbnation",
  YOUTUBE_SEARCH: "youtubeSearch",
  YOUTUBE_VIDEO: "youtubeVideo",
  SOUNDCLOUD_SEARCH: "soundcloudSearch",
  APPLE_MUSIC_SONG: "appleMusicSong",
  APPLE_MUSIC_ALBUM: "appleMusicAlbum",
  APPLE_MUSIC_PLAYLIST: "appleMusicPlaylist",
  APPLE_MUSIC_SEARCH: "appleMusicSearch",
  FILE: "file",
  AUTO_SEARCH: "autoSearch"
};
var PlayerEvent = /* @__PURE__ */ ((PlayerEvent2) => {
  PlayerEvent2["debug"] = "debug";
  PlayerEvent2["error"] = "error";
  PlayerEvent2["voiceStateUpdate"] = "voiceStateUpdate";
  return PlayerEvent2;
})(PlayerEvent || {});
var QueueRepeatMode = /* @__PURE__ */ ((QueueRepeatMode2) => {
  QueueRepeatMode2[QueueRepeatMode2["OFF"] = 0] = "OFF";
  QueueRepeatMode2[QueueRepeatMode2["TRACK"] = 1] = "TRACK";
  QueueRepeatMode2[QueueRepeatMode2["QUEUE"] = 2] = "QUEUE";
  QueueRepeatMode2[QueueRepeatMode2["AUTOPLAY"] = 3] = "AUTOPLAY";
  return QueueRepeatMode2;
})(QueueRepeatMode || {});

// src/utils/QueryResolver.ts
var soundcloud = __toESM(require("soundcloud-scraper"));
var spotifySongRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(?:track\/|\?uri=spotify:track:)((\w|-){22})(\?si=.+)?$/;
var spotifyPlaylistRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(?:playlist\/|\?uri=spotify:playlist:)((\w|-){22})(\?si=.+)?$/;
var spotifyAlbumRegex = /^https?:\/\/(?:embed\.|open\.)(?:spotify\.com\/)(?:album\/|\?uri=spotify:album:)((\w|-){22})(\?si=.+)?$/;
var vimeoRegex = /^(http|https)?:\/\/(www\.|player\.)?vimeo\.com\/(?:channels\/(?:\w+\/)?|groups\/([^/]*)\/videos\/|video\/|)(\d+)(?:|\/\?)$/;
var reverbnationRegex = /^https:\/\/(www.)?reverbnation.com\/(.+)\/song\/(.+)$/;
var attachmentRegex = /^https?:\/\/.+$/;
var appleMusicSongRegex = /^https?:\/\/music\.apple\.com\/.+?\/(song|album)\/.+?(\/.+?\?i=|\/)([0-9]+)$/;
var appleMusicPlaylistRegex = /^https?:\/\/music\.apple\.com\/.+?\/playlist\/.+\/pl\.(u-)?[a-zA-Z0-9]+$/;
var appleMusicAlbumRegex = /^https?:\/\/music\.apple\.com\/.+?\/album\/.+\/([0-9]+)$/;
var QueryResolver = class {
  constructor() {
  }
  static get regex() {
    return {
      spotifyAlbumRegex,
      spotifyPlaylistRegex,
      spotifySongRegex,
      vimeoRegex,
      reverbnationRegex,
      attachmentRegex,
      appleMusicAlbumRegex,
      appleMusicPlaylistRegex,
      appleMusicSongRegex
    };
  }
  static resolve(query, fallbackSearchEngine = QueryType.AUTO_SEARCH) {
    query = !query.includes("youtube.com") ? query.trim() : query.replace(/(m(usic)?|gaming)\./, "").trim();
    if ((soundcloud.validateURL || soundcloud.default.validateURL)(query, "track"))
      return QueryType.SOUNDCLOUD_TRACK;
    if ((soundcloud.validateURL || soundcloud.default.validateURL)(query, "playlist") || query.includes("/sets/"))
      return QueryType.SOUNDCLOUD_PLAYLIST;
    if (import_youtube_sr.YouTube.isPlaylist(query))
      return QueryType.YOUTUBE_PLAYLIST;
    if (QueryResolver.validateId(query) || QueryResolver.validateURL(query))
      return QueryType.YOUTUBE_VIDEO;
    if (spotifySongRegex.test(query))
      return QueryType.SPOTIFY_SONG;
    if (spotifyPlaylistRegex.test(query))
      return QueryType.SPOTIFY_PLAYLIST;
    if (spotifyAlbumRegex.test(query))
      return QueryType.SPOTIFY_ALBUM;
    if (vimeoRegex.test(query))
      return QueryType.VIMEO;
    if (reverbnationRegex.test(query))
      return QueryType.REVERBNATION;
    if (appleMusicAlbumRegex.test(query))
      return QueryType.APPLE_MUSIC_ALBUM;
    if (appleMusicPlaylistRegex.test(query))
      return QueryType.APPLE_MUSIC_PLAYLIST;
    if (appleMusicSongRegex.test(query))
      return QueryType.APPLE_MUSIC_SONG;
    if (attachmentRegex.test(query))
      return QueryType.ARBITRARY;
    return fallbackSearchEngine;
  }
  static getVimeoID(query) {
    return QueryResolver.resolve(query) === QueryType.VIMEO ? query.split("/").filter((x) => !!x).pop() : null;
  }
  static validateId(q) {
    return import_youtube_sr.YouTube.Regex.VIDEO_ID.test(q);
  }
  static validateURL(q) {
    return import_youtube_sr.YouTube.Regex.VIDEO_URL.test(q);
  }
};
__name(QueryResolver, "QueryResolver");

// src/Structures/Track.ts
var import_discord = require("discord.js");
var Track = class {
  constructor(player, data) {
    this.requestedBy = null;
    this.queryType = null;
    this.raw = {
      source: "arbitrary"
    };
    this.extractor = null;
    this.id = import_discord.SnowflakeUtil.generate().toString();
    Object.defineProperty(this, "player", { value: player, enumerable: false });
    void this._patch(data);
  }
  _patch(data) {
    this.title = (0, import_discord.escapeMarkdown)(data.title ?? "");
    this.author = data.author ?? "";
    this.url = data.url ?? "";
    this.thumbnail = data.thumbnail ?? "";
    this.duration = data.duration ?? "";
    this.views = data.views ?? 0;
    this.queryType = data.queryType;
    this.requestedBy = data.requestedBy || null;
    this.playlist = data.playlist;
    this.raw = Object.assign({}, { source: data.raw?.source ?? data.source }, data.raw ?? data);
  }
  get queue() {
    return this.player.nodes.cache.find((q) => q.tracks.some((ab) => ab.id === this.id));
  }
  get durationMS() {
    const times = /* @__PURE__ */ __name((n, t) => {
      let tn = 1;
      for (let i = 0; i < t; i++)
        tn *= n;
      return t <= 0 ? 1e3 : tn * 1e3;
    }, "times");
    return this.duration.split(":").reverse().map((m, i) => parseInt(m) * times(60, i)).reduce((a, c) => a + c, 0);
  }
  get source() {
    return this.raw?.source ?? "arbitrary";
  }
  toString() {
    return `${this.title} by ${this.author}`;
  }
  toJSON(hidePlaylist) {
    return {
      id: this.id,
      title: this.title,
      description: this.description,
      author: this.author,
      url: this.url,
      thumbnail: this.thumbnail,
      duration: this.duration,
      durationMS: this.durationMS,
      views: this.views,
      requestedBy: this.requestedBy?.id || null,
      playlist: hidePlaylist ? null : this.playlist?.toJSON() ?? null
    };
  }
};
__name(Track, "Track");

// src/Structures/GuildQueuePlayerNode.ts
var import_promises2 = require("timers/promises");
var FFMPEG_SRATE_REGEX = /asetrate=\d+\*(\d(\.\d)?)/;
var _progress, _performPlay, performPlay_fn, _createGenericStream, createGenericStream_fn, _createFFmpegStream, createFFmpegStream_fn;
var GuildQueuePlayerNode = class {
  constructor(queue) {
    this.queue = queue;
    __privateAdd(this, _performPlay);
    __privateAdd(this, _createGenericStream);
    __privateAdd(this, _createFFmpegStream);
    __privateAdd(this, _progress, 0);
  }
  isIdle() {
    return !!this.queue.dispatcher?.isIdle();
  }
  isBuffering() {
    return !!this.queue.dispatcher?.isBuffering();
  }
  isPlaying() {
    return !!this.queue.dispatcher?.isPlaying();
  }
  isPaused() {
    return !!this.queue.dispatcher?.isPaused();
  }
  resetProgress() {
    __privateSet(this, _progress, 0);
  }
  get streamTime() {
    return this.queue.dispatcher?.streamTime ?? 0;
  }
  get playbackTime() {
    const dur = __privateGet(this, _progress) + this.streamTime;
    return dur;
  }
  getDurationMultiplier() {
    const srateFilters = this.queue.filters.ffmpeg.toArray().filter((ff) => FFMPEG_SRATE_REGEX.test(ff));
    const multipliers = srateFilters.map((m) => {
      return parseFloat(FFMPEG_SRATE_REGEX.exec(m)?.[1]);
    }).filter((f) => !isNaN(f));
    return !multipliers.length ? 1 : multipliers.reduce((accumulator, current) => current + accumulator);
  }
  get estimatedPlaybackTime() {
    const dur = this.playbackTime;
    return Math.round(this.getDurationMultiplier() * dur);
  }
  get estimatedDuration() {
    const dur = this.queue.currentTrack?.durationMS ?? 0;
    return Math.round(dur / this.getDurationMultiplier());
  }
  getTimestamp(ignoreFilters = false) {
    if (!this.queue.currentTrack)
      return null;
    const current = ignoreFilters ? this.playbackTime : this.estimatedPlaybackTime;
    const total = ignoreFilters ? this.queue.currentTrack.durationMS : this.estimatedDuration;
    return {
      current: {
        label: Util.buildTimeCode(Util.parseMS(current)),
        value: current
      },
      total: {
        label: Util.buildTimeCode(Util.parseMS(total)),
        value: total
      },
      progress: Math.round(current / total * 100)
    };
  }
  createProgressBar(options) {
    const timestamp = this.getTimestamp();
    if (!timestamp)
      return null;
    const { indicator = "\u{1F518}", length = 15, line = "\u25AC", timecodes = true } = options || {};
    if (isNaN(length) || length < 0 || !Number.isFinite(length))
      throw new Error("invalid progressbar length");
    const index = Math.round(timestamp.current.value / timestamp.total.value * length);
    if (index >= 1 && index <= length) {
      const bar = line.repeat(length - 1).split("");
      bar.splice(index, 0, indicator);
      if (timecodes) {
        return `${timestamp.current.label} \u2503 ${bar.join("")} \u2503 ${timestamp.total.label}`;
      } else {
        return `${bar.join("")}`;
      }
    } else {
      if (timecodes) {
        return `${timestamp.current.label} \u2503 ${indicator}${line.repeat(length - 1)} \u2503 ${timestamp.total.label}`;
      } else {
        return `${indicator}${line.repeat(length - 1)}`;
      }
    }
  }
  async seek(duration) {
    if (!this.queue.currentTrack)
      return false;
    return await this.queue.filters.triggerReplay(duration);
  }
  get volume() {
    return this.queue.dispatcher?.volume ?? 100;
  }
  setVolume(vol) {
    if (!this.queue.dispatcher)
      return false;
    const res = this.queue.dispatcher.setVolume(vol);
    if (res)
      this.queue.filters._lastFiltersCache.volume = vol;
    return res;
  }
  setBitrate(rate) {
    this.queue.dispatcher?.audioResource?.encoder?.setBitrate(rate === "auto" ? this.queue.channel?.bitrate ?? 64e3 : rate);
  }
  setPaused(state) {
    if (state)
      return this.queue.dispatcher?.pause(true) || false;
    return this.queue.dispatcher?.resume() || false;
  }
  pause() {
    return this.setPaused(true);
  }
  resume() {
    return this.setPaused(false);
  }
  skip() {
    if (!this.queue.dispatcher)
      return false;
    this.queue.setTransitioning(false);
    this.queue.dispatcher.end();
    return true;
  }
  remove(track) {
    const foundTrack = this.queue.tracks.find((t, idx) => {
      if (track instanceof Track || typeof track === "string") {
        return (typeof track === "string" ? track : track.id) === t.id;
      }
      if (typeof track === "string")
        return track === t.id;
      return idx === track;
    });
    if (!foundTrack)
      return null;
    this.queue.tracks.removeOne((t) => t.id === foundTrack.id);
    this.queue.player.events.emit("audioTrackRemove", this.queue, foundTrack);
    return foundTrack;
  }
  jump(track) {
    const removed = this.remove(track);
    if (!removed)
      return false;
    this.queue.tracks.store.unshift(removed);
    return this.skip();
  }
  getTrackPosition(track) {
    return this.queue.tracks.toArray().findIndex((t, idx) => {
      if (track instanceof Track || typeof track === "string") {
        return (typeof track === "string" ? track : track.id) === t.id;
      }
      if (typeof track === "string")
        return track === t.id;
      return idx === track;
    });
  }
  skipTo(track) {
    const idx = this.getTrackPosition(track);
    if (idx < 0)
      return false;
    const removed = this.remove(idx);
    if (!removed)
      return false;
    const toRemove = this.queue.tracks.store.filter((_, i) => i <= idx);
    this.queue.tracks.store.splice(0, idx, removed);
    this.queue.player.events.emit("audioTracksRemove", this.queue, toRemove);
    return this.skip();
  }
  insert(track, index = 0) {
    if (!(track instanceof Track))
      throw new Error("invalid track");
    this.queue.tracks.store.splice(index, 0, track);
    if (!this.queue.options.noEmitInsert)
      this.queue.player.events.emit("audioTrackAdd", this.queue, track);
  }
  move(from, to) {
    const removed = this.remove(from);
    if (!removed)
      throw new Error("invalid track to move");
    this.insert(removed, to);
  }
  copy(from, to) {
    const src = this.queue.tracks.at(this.getTrackPosition(from));
    if (!src)
      throw new Error("invalid track to copy");
    this.insert(src, to);
  }
  swap(first, second) {
    const src = this.getTrackPosition(first);
    if (src < 0)
      throw new Error("invalid src track to swap");
    const dest = this.getTrackPosition(second);
    if (dest < 0)
      throw new Error("invalid dest track to swap");
    const srcT = this.queue.tracks.store[src];
    const destT = this.queue.tracks.store[dest];
    this.queue.tracks.store[src] = destT;
    this.queue.tracks.store[dest] = srcT;
  }
  stop(force = false) {
    this.queue.tracks.clear();
    this.queue.history.clear();
    if (!this.queue.dispatcher)
      return false;
    this.queue.dispatcher.end();
    if (force) {
      this.queue.dispatcher.disconnect();
      return true;
    }
    if (this.queue.options.leaveOnStop) {
      const tm = setTimeout(() => {
        if (this.isPlaying() || this.queue.tracks.size)
          return clearTimeout(tm);
        this.queue.dispatcher?.disconnect();
      }, this.queue.options.leaveOnStopCooldown).unref();
    }
    return true;
  }
  async playRaw(resource) {
    await this.queue.dispatcher?.playStream(resource);
  }
  async play(res, options) {
    if (!this.queue.dispatcher?.voiceConnection) {
      throw new Error("No voice connection available");
    }
    this.queue.debug(`Received play request from guild ${this.queue.guild.name} (ID: ${this.queue.guild.id})`);
    options = Object.assign(
      {},
      {
        queue: this.queue.currentTrack != null,
        transitionMode: false,
        seek: 0
      },
      options
    );
    if (res && options.queue) {
      this.queue.debug("Requested option requires to queue the track, adding the given track to queue instead...");
      return this.queue.addTrack(res);
    }
    const track = res || this.queue.tracks.dispatch();
    if (!track) {
      throw new Error("Play request received but track was not provided");
    }
    if (this.queue.initializing) {
      this.queue.debug("Queue is currently initializing another track, waiting...");
      await this.queue.awaitInitialization();
      this.queue.debug("Queue has finished initialization...");
    }
    this.queue.debug("Requested option requires to play the track, initializing...");
    this.queue.initializing = true;
    try {
      this.queue.debug(`Initiating stream extraction process...`);
      const src = track.raw?.source || track.source;
      const qt = track.queryType || (src === "spotify" ? "spotifySong" : src === "apple_music" ? "appleMusicSong" : src);
      this.queue.debug(`Executing onBeforeCreateStream hook (QueryType: ${qt})...`);
      let stream = await this.queue.onBeforeCreateStream?.(track, qt || "arbitrary", this.queue).catch(() => null);
      if (!stream) {
        this.queue.debug("Failed to get stream from onBeforeCreateStream!");
        stream = await __privateMethod(this, _createGenericStream, createGenericStream_fn).call(this, track).catch(() => null);
      }
      if (!stream) {
        const error = new Error("Could not extract stream for this track");
        if (this.queue.options.skipOnNoStream) {
          this.queue.player.events.emit("playerSkip", this.queue, track);
          this.queue.player.events.emit("playerError", this.queue, error, track);
          this.queue.initializing = false;
          const nextTrack = this.queue.tracks.dispatch();
          if (nextTrack)
            this.play(null, { queue: false });
          return;
        }
        throw error;
      }
      if (typeof options.seek === "number" && options.seek >= 0) {
        __privateSet(this, _progress, options.seek);
      } else {
        __privateSet(this, _progress, 0);
      }
      const cookies = track.raw?.source === "youtube" ? this.queue.player.options.ytdlOptions?.requestOptions?.headers?.cookie : void 0;
      const pcmStream = __privateMethod(this, _createFFmpegStream, createFFmpegStream_fn).call(this, stream, track, options.seek ?? 0, cookies);
      if (options.transitionMode) {
        this.queue.debug(`Transition mode detected, player will wait for buffering timeout to expire (Timeout: ${this.queue.options.bufferingTimeout}ms)`);
        await (0, import_promises2.setTimeout)(this.queue.options.bufferingTimeout);
        this.queue.debug("Buffering timeout has expired!");
      }
      this.queue.debug(
        `Preparing final stream config: ${JSON.stringify(
          {
            disableBiquad: this.queue.options.biquad === false,
            disableEqualizer: this.queue.options.equalizer === false,
            disableVolume: this.queue.options.volume === false,
            disableFilters: this.queue.options.filterer === false,
            disableResampler: this.queue.options.resampler === false,
            sampleRate: typeof this.queue.options.resampler === "number" && this.queue.options.resampler > 0 ? this.queue.options.resampler : void 0,
            biquadFilter: this.queue.filters._lastFiltersCache.biquad || void 0,
            eq: this.queue.filters._lastFiltersCache.equalizer,
            defaultFilters: this.queue.filters._lastFiltersCache.filters,
            volume: this.queue.filters._lastFiltersCache.volume,
            transitionMode: !!options.transitionMode,
            ffmpegFilters: this.queue.filters.ffmpeg.toString(),
            seek: options.seek
          },
          null,
          2
        )}`
      );
      const resource = await this.queue.dispatcher.createStream(pcmStream, {
        disableBiquad: this.queue.options.biquad === false,
        disableEqualizer: this.queue.options.equalizer === false,
        disableVolume: this.queue.options.volume === false,
        disableFilters: this.queue.options.filterer === false,
        disableResampler: this.queue.options.resampler === false,
        sampleRate: typeof this.queue.options.resampler === "number" && this.queue.options.resampler > 0 ? this.queue.options.resampler : void 0,
        biquadFilter: this.queue.filters._lastFiltersCache.biquad || void 0,
        eq: this.queue.filters._lastFiltersCache.equalizer,
        defaultFilters: this.queue.filters._lastFiltersCache.filters,
        volume: this.queue.filters._lastFiltersCache.volume,
        data: track,
        type: import_voice.StreamType.Raw
      });
      this.queue.setTransitioning(!!options.transitionMode);
      await __privateMethod(this, _performPlay, performPlay_fn).call(this, resource);
      this.queue.initializing = false;
    } catch (e) {
      this.queue.debug(`Failed to initialize audio player: ${e}`);
      this.queue.initializing = false;
      throw e;
    }
  }
};
__name(GuildQueuePlayerNode, "GuildQueuePlayerNode");
_progress = new WeakMap();
_performPlay = new WeakSet();
performPlay_fn = /* @__PURE__ */ __name(async function(resource) {
  this.queue.debug("Initializing audio player...");
  await this.queue.dispatcher.playStream(resource);
  this.queue.debug("Dispatching audio...");
}, "#performPlay");
_createGenericStream = new WeakSet();
createGenericStream_fn = /* @__PURE__ */ __name(async function(track) {
  this.queue.debug(`Attempting to extract stream for Track { title: ${track.title}, url: ${track.url} } using registered extractors`);
  const streamInfo = await this.queue.player.extractors.run(async (extractor) => {
    if (this.queue.player.options.blockStreamFrom?.some((ext) => ext === extractor.identifier))
      return false;
    const canStream = await extractor.validate(track.url, track.queryType || QueryResolver.resolve(track.url));
    if (!canStream)
      return false;
    return await extractor.stream(track);
  }, false);
  if (!streamInfo || !streamInfo.result) {
    this.queue.debug(`Failed to extract stream for Track { title: ${track.title}, url: ${track.url} } using registered extractors`);
    return null;
  }
  this.queue.debug(`Stream extraction was successful for Track { title: ${track.title}, url: ${track.url} } (Extractor: ${streamInfo.extractor.identifier})`);
  const stream = streamInfo.result;
  return stream;
}, "#createGenericStream");
_createFFmpegStream = new WeakSet();
createFFmpegStream_fn = /* @__PURE__ */ __name(function(stream, track, seek = 0, cookies) {
  const ffmpegStream = this.queue.filters.ffmpeg.createStream(stream, {
    encoderArgs: this.queue.filters.ffmpeg.filters.length ? ["-af", this.queue.filters.ffmpeg.toString()] : [],
    seek: seek / 1e3,
    fmt: "s16le",
    cookies
  }).on("error", (err) => {
    const m = `${err}`.toLowerCase();
    this.queue.debug(`Stream closed due to an error from FFmpeg stream: ${err.stack || err.message || err}`);
    if (m.includes("premature close") || m.includes("epipe"))
      return;
    this.queue.player.events.emit("playerError", this.queue, err, track);
  });
  return ffmpegStream;
}, "#createFFmpegStream");

// src/Structures/GuildQueueAudioFilters.ts
var import_equalizer = require("@discord-player/equalizer");

// src/utils/FFmpegStream.ts
var prism = __toESM(require("prism-media"));
function FFMPEG_ARGS_STRING(stream, fmt, cookies) {
  const args = [
    "-reconnect",
    "1",
    "-reconnect_streamed",
    "1",
    "-reconnect_delay_max",
    "5",
    "-i",
    stream,
    "-analyzeduration",
    "0",
    "-loglevel",
    "0",
    "-f",
    `${typeof fmt === "string" ? fmt : "s16le"}`,
    "-ar",
    "48000",
    "-ac",
    "2"
  ];
  if (typeof cookies === "string") {
    args.push("-cookies", cookies.startsWith('"') ? cookies : `"${cookies}"`);
  }
  return args;
}
__name(FFMPEG_ARGS_STRING, "FFMPEG_ARGS_STRING");
function FFMPEG_ARGS_PIPED(fmt) {
  return [
    "-analyzeduration",
    "0",
    "-loglevel",
    "0",
    "-f",
    `${typeof fmt === "string" ? fmt : "s16le"}`,
    "-ar",
    "48000",
    "-ac",
    "2"
  ];
}
__name(FFMPEG_ARGS_PIPED, "FFMPEG_ARGS_PIPED");
function createFFmpegStream(stream, options) {
  if (options?.skip && typeof stream !== "string")
    return stream;
  options ?? (options = {});
  const args = typeof stream === "string" ? FFMPEG_ARGS_STRING(stream, options.fmt, options.cookies) : FFMPEG_ARGS_PIPED(options.fmt);
  if (!Number.isNaN(options.seek))
    args.unshift("-ss", String(options.seek));
  if (Array.isArray(options.encoderArgs))
    args.push(...options.encoderArgs);
  const transcoder = new (prism.FFmpeg || prism.default.FFmpeg)({ shell: false, args });
  transcoder.on("close", () => transcoder.destroy());
  if (typeof stream !== "string") {
    stream.on("error", () => transcoder.destroy());
    stream.pipe(transcoder);
  }
  return transcoder;
}
__name(createFFmpegStream, "createFFmpegStream");

// src/Structures/GuildQueueAudioFilters.ts
var makeBands = /* @__PURE__ */ __name((arr) => {
  return Array.from(
    {
      length: import_equalizer.Equalizer.BAND_COUNT
    },
    (_, i) => ({
      band: i,
      gain: arr[i] ? arr[i] / 30 : 0
    })
  );
}, "makeBands");
var EqualizerConfigurationPreset = {
  Flat: makeBands([]),
  Classical: makeBands([-111022e-20, -111022e-20, -111022e-20, -111022e-20, -111022e-20, -111022e-20, -7.2, -7.2, -7.2, -9.6]),
  Club: makeBands([-111022e-20, -111022e-20, 8, 5.6, 5.6, 5.6, 3.2, -111022e-20, -111022e-20, -111022e-20]),
  Dance: makeBands([9.6, 7.2, 2.4, -111022e-20, -111022e-20, -5.6, -7.2, -7.2, -111022e-20, -111022e-20]),
  FullBass: makeBands([-8, 9.6, 9.6, 5.6, 1.6, -4, -8, -10.4, -11.2, -11.2]),
  FullBassTreble: makeBands([7.2, 5.6, -111022e-20, -7.2, -4.8, 1.6, 8, 11.2, 12, 12]),
  FullTreble: makeBands([-9.6, -9.6, -9.6, -4, 2.4, 11.2, 16, 16, 16, 16.8]),
  Headphones: makeBands([4.8, 11.2, 5.6, -3.2, -2.4, 1.6, 4.8, 9.6, 12.8, 14.4]),
  LargeHall: makeBands([10.4, 10.4, 5.6, 5.6, -111022e-20, -4.8, -4.8, -4.8, -111022e-20, -111022e-20]),
  Live: makeBands([-4.8, -111022e-20, 4, 5.6, 5.6, 5.6, 4, 2.4, 2.4, 2.4]),
  Party: makeBands([7.2, 7.2, -111022e-20, -111022e-20, -111022e-20, -111022e-20, -111022e-20, -111022e-20, 7.2, 7.2]),
  Pop: makeBands([-1.6, 4.8, 7.2, 8, 5.6, -111022e-20, -2.4, -2.4, -1.6, -1.6]),
  Reggae: makeBands([-111022e-20, -111022e-20, -111022e-20, -5.6, -111022e-20, 6.4, 6.4, -111022e-20, -111022e-20, -111022e-20]),
  Rock: makeBands([8, 4.8, -5.6, -8, -3.2, 4, 8.8, 11.2, 11.2, 11.2]),
  Ska: makeBands([-2.4, -4.8, -4, -111022e-20, 4, 5.6, 8.8, 9.6, 11.2, 9.6]),
  Soft: makeBands([4.8, 1.6, -111022e-20, -2.4, -111022e-20, 4, 8, 9.6, 11.2, 12]),
  SoftRock: makeBands([4, 4, 2.4, -111022e-20, -4, -5.6, -3.2, -111022e-20, 2.4, 8.8]),
  Techno: makeBands([8, 5.6, -111022e-20, -5.6, -4.8, -111022e-20, 8, 9.6, 9.6, 8.8])
};
var _ffmpegFilters, _setFilters, setFilters_fn;
var FFmpegFilterer = class {
  constructor(af) {
    this.af = af;
    __privateAdd(this, _setFilters);
    __privateAdd(this, _ffmpegFilters, []);
  }
  createStream(source, options) {
    return createFFmpegStream(source, options);
  }
  setFilters(filters) {
    let _filters = [];
    if (typeof filters === "boolean") {
      _filters = !filters ? [] : Object.keys(AudioFilters_default.filters);
    } else if (Array.isArray(filters)) {
      _filters = filters;
    } else {
      _filters = Object.entries(filters).filter((res) => res[1] === true).map((m) => m[0]);
    }
    return __privateMethod(this, _setFilters, setFilters_fn).call(this, _filters);
  }
  get filters() {
    return __privateGet(this, _ffmpegFilters);
  }
  set filters(filters) {
    this.setFilters(filters);
  }
  toggle(filters) {
    if (!Array.isArray(filters))
      filters = [filters];
    const fresh = [];
    filters.forEach((f) => {
      if (this.filters.includes(f))
        return;
      fresh.push(f);
    });
    return __privateMethod(this, _setFilters, setFilters_fn).call(this, __privateGet(this, _ffmpegFilters).filter((r) => !filters.includes(r)).concat(fresh));
  }
  setDefaults(ff) {
    __privateSet(this, _ffmpegFilters, ff);
  }
  getFiltersEnabled() {
    return __privateGet(this, _ffmpegFilters);
  }
  getFiltersDisabled() {
    return AudioFilters_default.names.filter((f) => !__privateGet(this, _ffmpegFilters).includes(f));
  }
  isEnabled(filter) {
    return __privateGet(this, _ffmpegFilters).includes(filter);
  }
  isDisabled(filter) {
    return !this.isEnabled(filter);
  }
  isValidFilter(filter) {
    return AudioFilters_default.has(filter);
  }
  toArray() {
    return this.filters.map((filter) => AudioFilters_default.get(filter));
  }
  toJSON() {
    const obj = {};
    this.filters.forEach((filter) => obj[filter] = AudioFilters_default.get(filter));
    return obj;
  }
  toString() {
    return AudioFilters_default.create(this.filters);
  }
};
__name(FFmpegFilterer, "FFmpegFilterer");
_ffmpegFilters = new WeakMap();
_setFilters = new WeakSet();
setFilters_fn = /* @__PURE__ */ __name(function(filters) {
  const ignoreFilters = this.filters.some((ff) => ff === "nightcore" || ff === "vaporwave") && !filters.some((ff) => ff === "nightcore" || ff === "vaporwave");
  const seekTime = this.af.queue.node.getTimestamp(ignoreFilters)?.current.value || 0;
  __privateSet(this, _ffmpegFilters, [...new Set(filters)]);
  return this.af.triggerReplay(seekTime);
}, "#setFilters");
var GuildQueueAudioFilters = class {
  constructor(queue) {
    this.queue = queue;
    this.graph = new AFilterGraph(this);
    this.ffmpeg = new FFmpegFilterer(this);
    this.equalizerPresets = EqualizerConfigurationPreset;
    this._lastFiltersCache = {
      biquad: null,
      equalizer: [],
      filters: [],
      volume: 100,
      sampleRate: -1
    };
    if (typeof this.queue.options.volume === "number") {
      this._lastFiltersCache.volume = this.queue.options.volume;
    }
  }
  get volume() {
    return this.queue.dispatcher?.dsp?.volume || null;
  }
  get equalizer() {
    return this.queue.dispatcher?.equalizer || null;
  }
  get biquad() {
    return this.queue.dispatcher?.biquad || null;
  }
  get filters() {
    return this.queue.dispatcher?.filters || null;
  }
  get resampler() {
    return this.queue.dispatcher?.resampler || null;
  }
  async triggerReplay(seek = 0) {
    if (!this.queue.currentTrack)
      return false;
    try {
      await this.queue.node.play(this.queue.currentTrack, {
        queue: false,
        seek,
        transitionMode: true
      });
      return true;
    } catch {
      return false;
    }
  }
};
__name(GuildQueueAudioFilters, "GuildQueueAudioFilters");
var AFilterGraph = class {
  constructor(af) {
    this.af = af;
  }
  get ffmpeg() {
    return this.af.ffmpeg.filters;
  }
  get equalizer() {
    return (this.af.equalizer?.bandMultipliers || []).map((m, i) => ({
      band: i,
      gain: m
    }));
  }
  get biquad() {
    return null;
  }
  get filters() {
    return this.af.filters?.filters || [];
  }
  get volume() {
    return this.af.volume;
  }
  get resampler() {
    return this.af.resampler;
  }
  dump() {
    return {
      ffmpeg: this.ffmpeg,
      equalizer: this.equalizer,
      biquad: this.biquad,
      filters: this.filters,
      sampleRate: this.resampler?.targetSampleRate || this.resampler?.sampleRate || 48e3,
      volume: this.volume?.volume ?? 100
    };
  }
};
__name(AFilterGraph, "AFilterGraph");

// src/Structures/GuildQueue.ts
var import_timers = require("timers");

// src/Structures/GuildQueueStatistics.ts
var GuildQueueStatistics = class {
  constructor(queue) {
    this.queue = queue;
  }
  generate() {
    return {
      latency: {
        eventLoop: this.queue.player.eventLoopLag,
        voiceConnection: this.queue.ping
      },
      status: {
        buffering: this.queue.node.isBuffering(),
        playing: this.queue.node.isPlaying(),
        paused: this.queue.node.isPaused(),
        idle: this.queue.node.isIdle()
      },
      tracksCount: this.queue.tracks.size,
      historySize: this.queue.history.tracks.size,
      extractors: this.queue.player.extractors.size,
      listeners: this.queue.guild.members.me?.voice.channel?.members.filter((m) => !m.user.bot).size || 0,
      memoryUsage: process.memoryUsage(),
      versions: {
        node: process.version,
        player: "6.1.1"
      }
    };
  }
};
__name(GuildQueueStatistics, "GuildQueueStatistics");

// src/utils/TypeUtil.ts
var TypeUtil = class {
  constructor() {
    return TypeUtil;
  }
  static isFunction(t) {
    return typeof t === "function";
  }
  static isNumber(t) {
    return typeof t === "number" && !isNaN(t);
  }
  static isString(t) {
    return typeof t === "string";
  }
  static isBoolean(t) {
    return typeof t === "boolean";
  }
  static isNullish(t) {
    return t == null;
  }
  static isArray(t) {
    return Array.isArray(t);
  }
};
__name(TypeUtil, "TypeUtil");

// src/Structures/GuildQueue.ts
var GuildQueueEvent = /* @__PURE__ */ ((GuildQueueEvent2) => {
  GuildQueueEvent2["audioTrackAdd"] = "audioTrackadd";
  GuildQueueEvent2["audioTracksAdd"] = "audioTracksAdd";
  GuildQueueEvent2["audioTrackRemove"] = "audioTrackRemove";
  GuildQueueEvent2["audioTracksRemove"] = "audioTracksRemove";
  GuildQueueEvent2["connection"] = "connection";
  GuildQueueEvent2["disconnect"] = "disconnect";
  GuildQueueEvent2["debug"] = "debug";
  GuildQueueEvent2["error"] = "error";
  GuildQueueEvent2["emptyChannel"] = "emptyChannel";
  GuildQueueEvent2["emptyQueue"] = "emptyQueue";
  GuildQueueEvent2["playerStart"] = "playerStart";
  GuildQueueEvent2["playerError"] = "playerError";
  GuildQueueEvent2["playerFinish"] = "playerFinish";
  GuildQueueEvent2["playerSkip"] = "playerSkip";
  GuildQueueEvent2["playerTrigger"] = "playerTrigger";
  GuildQueueEvent2["voiceStateUpdate"] = "voiceStateUpdate";
  return GuildQueueEvent2;
})(GuildQueueEvent || {});
var _transitioning, _initializing, _deleted, _initializingPromises, _attachListeners, attachListeners_fn, _removeListeners, removeListeners_fn, _performStart, performStart_fn, _performFinish, performFinish_fn, _emitEnd, emitEnd_fn, _handleAutoplay, handleAutoplay_fn, _resolveInitializerAwaiters, resolveInitializerAwaiters_fn;
var GuildQueue = class {
  constructor(player, options) {
    this.player = player;
    this.options = options;
    __privateAdd(this, _attachListeners);
    __privateAdd(this, _removeListeners);
    __privateAdd(this, _performStart);
    __privateAdd(this, _performFinish);
    __privateAdd(this, _emitEnd);
    __privateAdd(this, _handleAutoplay);
    __privateAdd(this, _resolveInitializerAwaiters);
    __privateAdd(this, _transitioning, false);
    __privateAdd(this, _initializing, false);
    __privateAdd(this, _deleted, false);
    __privateAdd(this, _initializingPromises, []);
    this.__current = null;
    this.history = new GuildQueueHistory(this);
    this.dispatcher = null;
    this.node = new GuildQueuePlayerNode(this);
    this.filters = new GuildQueueAudioFilters(this);
    this.onBeforeCreateStream = /* @__PURE__ */ __name(async () => null, "onBeforeCreateStream");
    this.onAfterCreateStream = /* @__PURE__ */ __name(async (stream) => ({
      stream,
      type: import_voice2.StreamType.Raw
    }), "onAfterCreateStream");
    this.repeatMode = 0 /* OFF */;
    this.timeouts = new import_utils4.Collection();
    this.stats = new GuildQueueStatistics(this);
    this.tracks = new import_utils4.Queue(options.queueStrategy);
    if (TypeUtil.isFunction(options.onBeforeCreateStream))
      this.onBeforeCreateStream = options.onBeforeCreateStream;
    if (TypeUtil.isFunction(options.onAfterCreateStream))
      this.onAfterCreateStream = options.onAfterCreateStream;
    if (!TypeUtil.isNullish(options.repeatMode))
      this.repeatMode = options.repeatMode;
    options.selfDeaf ?? (options.selfDeaf = true);
    if (!TypeUtil.isNullish(this.options.biquad) && !TypeUtil.isBoolean(this.options.biquad)) {
      this.filters._lastFiltersCache.biquad = this.options.biquad;
    }
    if (Array.isArray(this.options.equalizer)) {
      this.filters._lastFiltersCache.equalizer = this.options.equalizer;
    }
    if (Array.isArray(this.options.filterer)) {
      this.filters._lastFiltersCache.filters = this.options.filterer;
    }
    if (TypeUtil.isNumber(this.options.resampler)) {
      this.filters._lastFiltersCache.sampleRate = this.options.resampler;
    }
    if (TypeUtil.isArray(this.options.ffmpegFilters)) {
      this.filters.ffmpeg.setDefaults(this.options.ffmpegFilters);
    }
    this.debug(`GuildQueue initialized for guild ${this.options.guild.name} (ID: ${this.options.guild.id})`);
  }
  get estimatedDuration() {
    return this.tracks.store.reduce((a, c) => a + c.durationMS, 0);
  }
  get durationFormatted() {
    return Util.buildTimeCode(Util.parseMS(this.estimatedDuration));
  }
  get voiceReceiver() {
    return this.dispatcher?.receiver ?? null;
  }
  debug(m) {
    this.player.events.emit("debug", this, m);
  }
  get metadata() {
    return this.options.metadata;
  }
  set metadata(m) {
    this.options.metadata = m;
  }
  setMetadata(m) {
    this.options.metadata = m;
  }
  get initializing() {
    return __privateGet(this, _initializing);
  }
  set initializing(v) {
    __privateSet(this, _initializing, v);
    if (v)
      __privateMethod(this, _resolveInitializerAwaiters, resolveInitializerAwaiters_fn).call(this);
  }
  get currentTrack() {
    return this.dispatcher?.audioResource?.metadata || this.__current;
  }
  get deleted() {
    return __privateGet(this, _deleted);
  }
  get channel() {
    return this.dispatcher?.channel || null;
  }
  set channel(c) {
    if (this.dispatcher) {
      if (c) {
        this.dispatcher.channel = c;
      } else {
        this.delete();
      }
    }
  }
  get connection() {
    return this.dispatcher?.voiceConnection || null;
  }
  get guild() {
    return this.options.guild;
  }
  get id() {
    return this.guild.id;
  }
  setTransitioning(state) {
    __privateSet(this, _transitioning, state);
  }
  isTransitioning() {
    return __privateGet(this, _transitioning);
  }
  setRepeatMode(mode) {
    this.repeatMode = mode;
  }
  get size() {
    return this.tracks.size;
  }
  getSize() {
    return this.size;
  }
  clear() {
    this.tracks.clear();
    this.history.clear();
  }
  isEmpty() {
    return this.tracks.size < 1;
  }
  isPlaying() {
    return this.dispatcher?.audioResource != null && !this.dispatcher.audioResource.ended;
  }
  addTrack(track) {
    const toAdd = track instanceof Playlist ? track.tracks : track;
    this.tracks.add(toAdd);
    const isMulti = Array.isArray(toAdd);
    if (isMulti) {
      this.player.events.emit("audioTracksAdd", this, toAdd);
    } else {
      this.player.events.emit("audioTrackAdd", this, toAdd);
    }
  }
  removeTrack(track) {
    return this.node.remove(track);
  }
  insertTrack(track, index = 0) {
    return this.node.insert(track, index);
  }
  moveTrack(track, index = 0) {
    return this.node.move(track, index);
  }
  copyTrack(track, index = 0) {
    return this.node.copy(track, index);
  }
  swapTracks(src, dest) {
    return this.node.swap(src, dest);
  }
  async connect(channelResolvable, options = {}) {
    const channel = this.player.client.channels.resolve(channelResolvable);
    if (!channel || !channel.isVoiceBased()) {
      throw new Error(`Expected a voice based channel (type ${import_discord2.ChannelType.GuildVoice}/${import_discord2.ChannelType.GuildStageVoice}), received ${channel?.type}`);
    }
    this.debug(`Connecting to ${channel.type === import_discord2.ChannelType.GuildStageVoice ? "stage" : "voice"} channel ${channel.name} (ID: ${channel.id})`);
    if (this.dispatcher) {
      this.debug("Destroying old connection");
      __privateMethod(this, _removeListeners, removeListeners_fn).call(this, this.dispatcher);
      this.dispatcher.disconnect();
    }
    this.dispatcher = await this.player.voiceUtils.connect(channel, {
      deaf: options.deaf ?? this.options.selfDeaf ?? true,
      maxTime: options?.timeout ?? this.options.connectionTimeout ?? 12e4,
      queue: this
    });
    this.player.events.emit("connection", this);
    if (this.channel.type === import_discord2.ChannelType.GuildStageVoice) {
      await this.channel.guild.members.me.voice.setSuppressed(false).catch(async () => {
        return await this.channel.guild.members.me.voice.setRequestToSpeak(true).catch(Util.noop);
      });
    }
    __privateMethod(this, _attachListeners, attachListeners_fn).call(this, this.dispatcher);
    return this;
  }
  get ping() {
    return this.connection?.ping.udp ?? -1;
  }
  delete() {
    if (this.player.nodes.delete(this.id)) {
      __privateSet(this, _deleted, true);
    }
  }
  revive() {
    if (!this.deleted || this.player.nodes.has(this.id))
      return;
    __privateSet(this, _deleted, false);
    this.player.nodes.cache.set(this.id, this);
  }
  awaitInitialization() {
    return new Promise((r) => {
      if (!__privateGet(this, _initializing))
        return r(true);
      __privateGet(this, _initializingPromises).push(r);
    });
  }
  setSelfDeaf(mode, reason) {
    return this.guild.members.me.voice.setDeaf(mode, reason);
  }
  setSelfMute(mode, reason) {
    return this.guild.members.me.voice.setMute(mode, reason);
  }
};
__name(GuildQueue, "GuildQueue");
_transitioning = new WeakMap();
_initializing = new WeakMap();
_deleted = new WeakMap();
_initializingPromises = new WeakMap();
_attachListeners = new WeakSet();
attachListeners_fn = /* @__PURE__ */ __name(function(dispatcher) {
  dispatcher.on("error", (e) => this.player.events.emit("error", this, e));
  dispatcher.on("debug", (m) => this.player.events.emit("debug", this, m));
  dispatcher.on("finish", (r) => __privateMethod(this, _performFinish, performFinish_fn).call(this, r));
  dispatcher.on("start", (r) => __privateMethod(this, _performStart, performStart_fn).call(this, r));
  dispatcher.on("dsp", (f) => {
    this.filters._lastFiltersCache.filters = f;
  });
  dispatcher.on("biquad", (f) => {
    this.filters._lastFiltersCache.biquad = f;
  });
  dispatcher.on("eqBands", (f) => {
    this.filters._lastFiltersCache.equalizer = f;
  });
  dispatcher.on("volume", (f) => {
    this.filters._lastFiltersCache.volume = f;
  });
}, "#attachListeners");
_removeListeners = new WeakSet();
removeListeners_fn = /* @__PURE__ */ __name(function(dispatcher) {
  dispatcher.removeAllListeners();
}, "#removeListeners");
_performStart = new WeakSet();
performStart_fn = /* @__PURE__ */ __name(function(resource) {
  const track = resource?.metadata || this.currentTrack;
  const reason = this.isTransitioning() ? "filters" : "normal";
  this.debug(
    `Player triggered for Track ${JSON.stringify({
      title: track?.title,
      reason
    })}`
  );
  this.player.events.emit("playerTrigger", this, track, reason);
  if (track && !this.isTransitioning())
    this.player.events.emit("playerStart", this, track);
  this.setTransitioning(false);
  this.initializing = false;
}, "#performStart");
_performFinish = new WeakSet();
performFinish_fn = /* @__PURE__ */ __name(function(resource) {
  const track = resource?.metadata || this.currentTrack;
  this.debug(
    `Track ${JSON.stringify({
      title: track?.title,
      isTransitionMode: this.isTransitioning()
    })} was marked as finished`
  );
  if (track && !this.isTransitioning()) {
    this.debug("Adding track to history and emitting finish event since transition mode is disabled...");
    this.history.push(track);
    this.node.resetProgress();
    this.player.events.emit("playerFinish", this, track);
    if (this.tracks.size < 1 && this.repeatMode === 0 /* OFF */) {
      this.debug("No more tracks left in the queue to play and repeat mode is off, initiating #emitEnd()");
      __privateMethod(this, _emitEnd, emitEnd_fn).call(this);
    } else {
      if (this.repeatMode === 1 /* TRACK */) {
        this.debug("Repeat mode is set to track, repeating last track from the history...");
        this.__current = this.history.tracks.dispatch() || track;
        return this.node.play(this.__current, { queue: false });
      }
      if (this.repeatMode === 2 /* QUEUE */) {
        this.debug("Repeat mode is set to queue, moving last track from the history to current queue...");
        this.tracks.add(this.history.tracks.dispatch() || track);
      }
      if (!this.tracks.size) {
        if (this.repeatMode === 3 /* AUTOPLAY */) {
          this.debug("Repeat mode is set to autoplay, initiating autoplay handler...");
          __privateMethod(this, _handleAutoplay, handleAutoplay_fn).call(this, track);
          return;
        }
      } else {
        this.debug("Initializing next track of the queue...");
        this.__current = this.tracks.dispatch();
        this.node.play(this.__current, {
          queue: false
        });
      }
    }
  }
}, "#performFinish");
_emitEnd = new WeakSet();
emitEnd_fn = /* @__PURE__ */ __name(function() {
  this.__current = null;
  this.player.events.emit("emptyQueue", this);
  if (this.options.leaveOnEnd) {
    const tm = (0, import_timers.setTimeout)(() => {
      if (this.tracks.size)
        return clearTimeout(tm);
      this.dispatcher?.disconnect();
    }, this.options.leaveOnEndCooldown).unref();
  }
}, "#emitEnd");
_handleAutoplay = new WeakSet();
handleAutoplay_fn = /* @__PURE__ */ __name(async function(track) {
  try {
    this.debug(`Autoplay >> Finding related tracks for Track ${track.title} (${track.url}) [ext:${track.extractor?.identifier || "N/A"}]`);
    const tracks = (await track.extractor?.getRelatedTracks(track))?.tracks || (await this.player.extractors.run(async (ext) => {
      this.debug(`Autoplay >> Querying extractor ${ext.identifier}`);
      const res = await ext.getRelatedTracks(track);
      if (!res.tracks.length) {
        this.debug(`Autoplay >> Extractor ${ext.identifier} failed to provide results.`);
        return false;
      }
      this.debug(`Autoplay >> Extractor ${ext.identifier} successfully returned results.`);
      return res.tracks;
    }))?.result;
    if (!tracks?.length) {
      this.debug(`Autoplay >> No related tracks found.`);
      throw "no related tracks";
    }
    this.debug(`Autoplay >> Picking random track from first 5 tracks...`);
    const nextTrack = Util.randomChoice(tracks.slice(0, 5));
    await this.node.play(nextTrack, {
      queue: false,
      seek: 0,
      transitionMode: false
    });
  } catch {
    return __privateMethod(this, _emitEnd, emitEnd_fn).call(this);
  }
}, "#handleAutoplay");
_resolveInitializerAwaiters = new WeakSet();
resolveInitializerAwaiters_fn = /* @__PURE__ */ __name(function() {
  __privateGet(this, _initializingPromises).forEach((p) => {
    p(!__privateGet(this, _initializing));
  });
  __privateSet(this, _initializingPromises, []);
}, "#resolveInitializerAwaiters");

// src/utils/__internal__/_container.ts
var import_utils5 = require("@discord-player/utils");
var instances = new import_utils5.Collection();
var globalRegistry = new import_utils5.Collection();

// src/utils/__internal__/addPlayer.ts
function addPlayer(player) {
  if (instances.has(player.id))
    return true;
  instances.set(player.id, player);
  return instances.has(player.id);
}
__name(addPlayer, "addPlayer");

// src/utils/__internal__/clearPlayer.ts
function clearPlayer(player) {
  return instances.delete(player.id);
}
__name(clearPlayer, "clearPlayer");

// src/utils/__internal__/getPlayers.ts
function getPlayers() {
  return instances.array();
}
__name(getPlayers, "getPlayers");

// src/utils/__internal__/getGlobalRegistry.ts
function getGlobalRegistry() {
  return globalRegistry;
}
__name(getGlobalRegistry, "getGlobalRegistry");

// src/Structures/GuildNodeManager.ts
var GuildNodeManager = class {
  constructor(player) {
    this.player = player;
    this.cache = new import_utils6.Collection();
  }
  create(guild, options = {}) {
    const server = this.player.client.guilds.resolve(guild);
    if (!server) {
      throw new Error("Invalid or unknown guild");
    }
    if (this.cache.has(server.id)) {
      return this.cache.get(server.id);
    }
    options.strategy ?? (options.strategy = "FIFO");
    options.volume ?? (options.volume = 100);
    options.equalizer ?? (options.equalizer = []);
    options.a_filter ?? (options.a_filter = []);
    options.disableHistory ?? (options.disableHistory = false);
    options.skipOnNoStream ?? (options.skipOnNoStream = false);
    options.leaveOnEmpty ?? (options.leaveOnEmpty = true);
    options.leaveOnEmptyCooldown ?? (options.leaveOnEmptyCooldown = 0);
    options.leaveOnEnd ?? (options.leaveOnEnd = true);
    options.leaveOnEndCooldown ?? (options.leaveOnEndCooldown = 0);
    options.leaveOnStop ?? (options.leaveOnStop = true);
    options.leaveOnStopCooldown ?? (options.leaveOnStopCooldown = 0);
    options.resampler ?? (options.resampler = 48e3);
    options.selfDeaf ?? (options.selfDeaf = true);
    options.connectionTimeout ?? (options.connectionTimeout = this.player.options.connectionTimeout);
    options.bufferingTimeout ?? (options.bufferingTimeout = 1e3);
    if (getGlobalRegistry().has("@[onBeforeCreateStream]") && !options.onBeforeCreateStream) {
      options.onBeforeCreateStream = getGlobalRegistry().get("@[onBeforeCreateStream]");
    }
    if (getGlobalRegistry().has("@[onAfterCreateStream]") && !options.onAfterCreateStream) {
      options.onAfterCreateStream = getGlobalRegistry().get("@[onAfterCreateStream]");
    }
    const queue = new GuildQueue(this.player, {
      guild: server,
      queueStrategy: options.strategy,
      volume: options.volume,
      equalizer: options.equalizer,
      filterer: options.a_filter,
      biquad: options.biquad,
      resampler: options.resampler,
      disableHistory: options.disableHistory,
      skipOnNoStream: options.skipOnNoStream,
      onBeforeCreateStream: options.onBeforeCreateStream,
      onAfterCreateStream: options.onAfterCreateStream,
      repeatMode: options.repeatMode,
      leaveOnEmpty: options.leaveOnEmpty,
      leaveOnEmptyCooldown: options.leaveOnEmptyCooldown,
      leaveOnEnd: options.leaveOnEnd,
      leaveOnEndCooldown: options.leaveOnEndCooldown,
      leaveOnStop: options.leaveOnStop,
      leaveOnStopCooldown: options.leaveOnStopCooldown,
      metadata: options.metadata,
      connectionTimeout: options.connectionTimeout ?? 12e4,
      selfDeaf: options.selfDeaf,
      ffmpegFilters: options.defaultFFmpegFilters ?? [],
      bufferingTimeout: options.bufferingTimeout,
      noEmitInsert: options.noEmitInsert ?? false
    });
    this.cache.set(server.id, queue);
    return queue;
  }
  get(node) {
    const queue = this.resolve(node);
    if (!queue)
      return null;
    return this.cache.get(queue.id) || null;
  }
  has(node) {
    const id = node instanceof GuildQueue ? node.id : this.player.client.guilds.resolveId(node);
    return this.cache.has(id);
  }
  delete(node) {
    const queue = this.resolve(node);
    if (!queue)
      throw new Error("Cannot delete non-existing queue");
    queue.node.stop(true);
    queue.connection?.removeAllListeners();
    queue.dispatcher?.removeAllListeners();
    queue.dispatcher?.disconnect();
    queue.timeouts.forEach((tm) => clearTimeout(tm));
    queue.history.clear();
    queue.tracks.clear();
    return this.cache.delete(queue.id);
  }
  resolve(node) {
    if (node instanceof GuildQueue) {
      return node;
    }
    return this.cache.get(this.player.client.guilds.resolveId(node));
  }
  resolveId(node) {
    const q = this.resolve(node);
    return q?.id || null;
  }
};
__name(GuildNodeManager, "GuildNodeManager");

// src/Structures/VoiceReceiverNode.ts
var import_stream = require("stream");
var import_voice3 = require("@discordjs/voice");
var prism2 = __toESM(require("prism-media"));
var VoiceReceiverNode = class {
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
  }
  createRawTrack(stream, data = {}) {
    data.title ?? (data.title = `Recording ${Date.now()}`);
    return new Track(this.dispatcher.queue.player, {
      author: "Discord",
      description: data.title,
      title: data.title,
      duration: data.duration || "0:00",
      views: 0,
      requestedBy: data.requestedBy,
      thumbnail: data.thumbnail || "https://cdn.discordapp.com/embed/avatars/0.png",
      url: data.url || "https://discord.com",
      source: "arbitrary",
      raw: {
        engine: stream,
        source: "arbitrary"
      }
    });
  }
  mergeRecordings(streams) {
    throw new Error("Not implemented");
  }
  recordUser(user, options = {
    end: import_voice3.EndBehaviorType.AfterSilence,
    mode: "pcm",
    silenceDuration: 1e3
  }) {
    const _user = this.dispatcher.queue.player.client.users.resolveId(user);
    const passThrough = new import_stream.PassThrough();
    const receiver = this.dispatcher.voiceConnection.receiver;
    if (!receiver)
      throw new Error("Voice receiver is not available, maybe connect to a voice channel first?");
    receiver.speaking.on("start", (userId) => {
      if (userId === _user) {
        const receiveStream = receiver.subscribe(_user, {
          end: {
            behavior: options.end || import_voice3.EndBehaviorType.AfterSilence,
            duration: options.silenceDuration ?? 1e3
          }
        });
        setImmediate(async () => {
          if (options.mode === "pcm") {
            const pcm = receiveStream.pipe(
              new (prism2.opus || prism2.default.opus).Decoder({
                channels: 2,
                frameSize: 960,
                rate: 48e3
              })
            );
            return pcm.pipe(passThrough);
          } else {
            return receiveStream.pipe(passThrough);
          }
        }).unref();
      }
    });
    return passThrough;
  }
};
__name(VoiceReceiverNode, "VoiceReceiverNode");

// src/Structures/SearchResult.ts
var SearchResult = class {
  constructor(player, _data) {
    this.player = player;
    this._data = _data;
    this._data.tracks?.forEach((track) => {
      track.extractor ?? (track.extractor = this._data.extractor || null);
      track.requestedBy ?? (track.requestedBy = _data.requestedBy || null);
    });
  }
  setQueryType(type) {
    this._data.queryType = type;
    return this;
  }
  setRequestedBy(user) {
    this._data.requestedBy = user;
    this._data.tracks?.forEach((track) => {
      track.requestedBy = user;
    });
    return this;
  }
  setExtractor(extractor) {
    this._data.extractor = extractor;
    this._data.tracks?.forEach((track) => {
      track.extractor = extractor;
    });
    return this;
  }
  setTracks(tracks) {
    this._data.tracks = tracks;
    return this;
  }
  setQuery(query) {
    this._data.query = query;
    return this;
  }
  setPlaylist(playlist) {
    this._data.playlist = playlist;
    return this;
  }
  get query() {
    return this._data.query;
  }
  get queryType() {
    return this._data.queryType || QueryType.AUTO;
  }
  get extractor() {
    return this._data.extractor || null;
  }
  get playlist() {
    return this._data.playlist;
  }
  get tracks() {
    return this._data.tracks || [];
  }
  get requestedBy() {
    return this._data.requestedBy || null;
  }
  async execute() {
    return this.player.search(this.query, {
      searchEngine: this.queryType,
      requestedBy: this.requestedBy
    });
  }
  isEmpty() {
    return !this.tracks.length;
  }
  hasPlaylist() {
    return this.playlist != null;
  }
  hasTracks() {
    return this.tracks.length > 0;
  }
  toJSON() {
    return {
      query: this.query,
      queryType: this.queryType,
      playlist: this.playlist?.toJSON(false) || null,
      tracks: this.tracks.map((m) => m.toJSON(true)),
      extractor: this.extractor?.identifier || null,
      requestedBy: this.requestedBy?.toJSON() || null
    };
  }
};
__name(SearchResult, "SearchResult");

// src/Structures/PlayerError.ts
var ErrorStatusCode = /* @__PURE__ */ ((ErrorStatusCode2) => {
  ErrorStatusCode2["STREAM_ERROR"] = "StreamError";
  ErrorStatusCode2["AUDIO_PLAYER_ERROR"] = "AudioPlayerError";
  ErrorStatusCode2["PLAYER_ERROR"] = "PlayerError";
  ErrorStatusCode2["NO_AUDIO_RESOURCE"] = "NoAudioResource";
  ErrorStatusCode2["UNKNOWN_GUILD"] = "UnknownGuild";
  ErrorStatusCode2["INVALID_ARG_TYPE"] = "InvalidArgType";
  ErrorStatusCode2["UNKNOWN_EXTRACTOR"] = "UnknownExtractor";
  ErrorStatusCode2["INVALID_EXTRACTOR"] = "InvalidExtractor";
  ErrorStatusCode2["INVALID_CHANNEL_TYPE"] = "InvalidChannelType";
  ErrorStatusCode2["INVALID_TRACK"] = "InvalidTrack";
  ErrorStatusCode2["UNKNOWN_REPEAT_MODE"] = "UnknownRepeatMode";
  ErrorStatusCode2["TRACK_NOT_FOUND"] = "TrackNotFound";
  ErrorStatusCode2["NO_CONNECTION"] = "NoConnection";
  ErrorStatusCode2["DESTROYED_QUEUE"] = "DestroyedQueue";
  return ErrorStatusCode2;
})(ErrorStatusCode || {});
var PlayerError = class extends Error {
  constructor(message, code = "PlayerError" /* PLAYER_ERROR */) {
    super();
    this.createdAt = new Date();
    this.message = `[${code}] ${message}`;
    this.statusCode = code;
    this.name = code;
    Error.captureStackTrace(this);
  }
  get createdTimestamp() {
    return this.createdAt.getTime();
  }
  valueOf() {
    return this.statusCode;
  }
  toJSON() {
    return {
      stack: this.stack,
      code: this.statusCode,
      message: this.message,
      created: this.createdTimestamp
    };
  }
  toString() {
    return this.stack;
  }
};
__name(PlayerError, "PlayerError");

// src/VoiceInterface/VoiceUtils.ts
var import_voice5 = require("@discordjs/voice");

// src/VoiceInterface/StreamDispatcher.ts
var import_voice4 = require("@discordjs/voice");
var import_utils7 = require("@discord-player/utils");
var import_equalizer2 = require("@discord-player/equalizer");
var needsKeepAlivePatch = (() => {
  if ("DP_NO_KEEPALIVE_PATCH" in process.env)
    return false;
  if (import_voice4.version.includes("-dev") || import_voice4.version.startsWith("1"))
    return false;
  const [_major, minor, patch] = import_voice4.version.split(".").map((n) => parseInt(n));
  return minor > 14 ? false : minor < 15 && patch < 1;
})();
var StreamDispatcher = class extends import_utils7.EventEmitter {
  constructor(connection, channel, queue, connectionTimeout = 2e4) {
    super();
    this.queue = queue;
    this.connectionTimeout = connectionTimeout;
    this.receiver = new VoiceReceiverNode(this);
    this.readyLock = false;
    this.dsp = new import_equalizer2.FiltersChain();
    this.voiceConnection = connection;
    this.audioPlayer = (0, import_voice4.createAudioPlayer)();
    this.channel = channel;
    this.voiceConnection.on("debug", (m) => void this.emit("debug", m));
    this.voiceConnection.on("error", (error) => void this.emit("error", error));
    this.audioPlayer.on("debug", (m) => void this.emit("debug", m));
    this.audioPlayer.on("error", (error) => void this.emit("error", error));
    this.dsp.onUpdate = () => {
      if (!this.dsp)
        return;
      if (this.dsp.filters?.filters)
        this.emit("dsp", this.dsp.filters?.filters);
      if (this.dsp.biquad?.filter)
        this.emit("biquad", this.dsp.biquad?.filter);
      if (this.dsp.equalizer)
        this.emit("eqBands", this.dsp.equalizer.getEQ());
      if (this.dsp.volume)
        this.emit("volume", this.dsp.volume.volume);
      if (this.dsp.resampler)
        this.emit("sampleRate", this.dsp.resampler.targetSampleRate);
    };
    this.dsp.onError = (e) => this.emit("error", e);
    this.voiceConnection.on("stateChange", async (oldState, newState) => {
      if (needsKeepAlivePatch) {
        this.queue.debug(`Detected @discordjs/voice version ${import_voice4.version} which needs keepAlive patch, applying patch...`);
        const oldNetworking = Reflect.get(oldState, "networking");
        const newNetworking = Reflect.get(newState, "networking");
        const networkStateChangeHandler = /* @__PURE__ */ __name((_, newNetworkState) => {
          const newUdp = Reflect.get(newNetworkState, "udp");
          clearInterval(newUdp?.keepAliveInterval);
        }, "networkStateChangeHandler");
        oldNetworking?.off("stateChange", networkStateChangeHandler);
        newNetworking?.on("stateChange", networkStateChangeHandler);
      }
      if (newState.status === import_voice4.VoiceConnectionStatus.Disconnected) {
        if (newState.reason === import_voice4.VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {
          try {
            await (0, import_voice4.entersState)(this.voiceConnection, import_voice4.VoiceConnectionStatus.Connecting, this.connectionTimeout);
          } catch {
            try {
              if (this.voiceConnection.state.status !== import_voice4.VoiceConnectionStatus.Destroyed)
                this.voiceConnection.destroy();
            } catch (err) {
              this.emit("error", err);
            }
          }
        } else if (this.voiceConnection.rejoinAttempts < 5) {
          await Util.wait((this.voiceConnection.rejoinAttempts + 1) * 5e3);
          this.voiceConnection.rejoin();
        } else {
          try {
            if (this.voiceConnection.state.status !== import_voice4.VoiceConnectionStatus.Destroyed)
              this.voiceConnection.destroy();
          } catch (err) {
            this.emit("error", err);
          }
        }
      } else if (newState.status === import_voice4.VoiceConnectionStatus.Destroyed) {
        this.end();
      } else if (!this.readyLock && (newState.status === import_voice4.VoiceConnectionStatus.Connecting || newState.status === import_voice4.VoiceConnectionStatus.Signalling)) {
        this.readyLock = true;
        try {
          await (0, import_voice4.entersState)(this.voiceConnection, import_voice4.VoiceConnectionStatus.Ready, this.connectionTimeout);
        } catch {
          if (this.voiceConnection.state.status !== import_voice4.VoiceConnectionStatus.Destroyed) {
            try {
              this.voiceConnection.destroy();
            } catch (err) {
              this.emit("error", err);
            }
          }
        } finally {
          this.readyLock = false;
        }
      }
    });
    this.audioPlayer.on("stateChange", (oldState, newState) => {
      if (newState.status === import_voice4.AudioPlayerStatus.Playing) {
        if (oldState.status === import_voice4.AudioPlayerStatus.Idle || oldState.status === import_voice4.AudioPlayerStatus.Buffering) {
          return this.emit("start", this.audioResource);
        }
      } else if (newState.status === import_voice4.AudioPlayerStatus.Idle && oldState.status !== import_voice4.AudioPlayerStatus.Idle) {
        this.emit("finish", this.audioResource);
        this.dsp.destroy();
        this.audioResource = null;
      }
    });
    this.voiceConnection.subscribe(this.audioPlayer);
  }
  get paused() {
    return this.audioPlayer.state.status === import_voice4.AudioPlayerStatus.Paused;
  }
  set paused(val) {
    val ? this.pause(true) : this.resume();
  }
  isPaused() {
    return this.paused || this.audioPlayer.state.status === import_voice4.AudioPlayerStatus.AutoPaused;
  }
  isBuffering() {
    return this.audioPlayer.state.status === import_voice4.AudioPlayerStatus.Buffering;
  }
  isPlaying() {
    return this.audioPlayer.state.status === import_voice4.AudioPlayerStatus.Playing;
  }
  isIdle() {
    return this.audioPlayer.state.status === import_voice4.AudioPlayerStatus.Idle;
  }
  isDestroyed() {
    return this.voiceConnection.state.status === import_voice4.VoiceConnectionStatus.Destroyed;
  }
  isDisconnected() {
    return this.voiceConnection.state.status === import_voice4.VoiceConnectionStatus.Disconnected;
  }
  isReady() {
    return this.voiceConnection.state.status === import_voice4.VoiceConnectionStatus.Ready;
  }
  isSignalling() {
    return this.voiceConnection.state.status === import_voice4.VoiceConnectionStatus.Signalling;
  }
  isConnecting() {
    return this.voiceConnection.state.status === import_voice4.VoiceConnectionStatus.Connecting;
  }
  async createStream(src, ops) {
    if (!ops?.disableFilters)
      this.queue.debug("Initiating DSP filters pipeline...");
    const stream = !ops?.disableFilters ? this.dsp.create(src, {
      dsp: {
        filters: ops?.defaultFilters,
        disabled: ops?.disableFilters
      },
      biquad: ops?.biquadFilter ? {
        filter: ops.biquadFilter,
        disabled: ops?.disableBiquad
      } : void 0,
      resampler: {
        targetSampleRate: ops?.sampleRate,
        disabled: ops?.disableResampler
      },
      equalizer: {
        bandMultiplier: ops?.eq,
        disabled: ops?.disableEqualizer
      },
      volume: {
        volume: ops?.volume,
        disabled: ops?.disableVolume
      }
    }) : src;
    this.queue.debug("Executing onAfterCreateStream hook...");
    const postStream = await this.queue.onAfterCreateStream?.(stream, this.queue).catch(
      () => ({
        stream,
        type: ops?.type ?? import_voice4.StreamType.Arbitrary
      })
    );
    this.queue.debug("Preparing AudioResource...");
    this.audioResource = (0, import_voice4.createAudioResource)(postStream?.stream ?? stream, {
      inputType: postStream?.type ?? ops?.type ?? import_voice4.StreamType.Arbitrary,
      metadata: ops?.data,
      inlineVolume: false
    });
    return this.audioResource;
  }
  get resampler() {
    return this.dsp?.resampler;
  }
  get filters() {
    return this.dsp?.filters;
  }
  get biquad() {
    return this.dsp?.biquad || null;
  }
  get equalizer() {
    return this.dsp?.equalizer || null;
  }
  get status() {
    return this.audioPlayer.state.status;
  }
  disconnect() {
    try {
      if (this.audioPlayer)
        this.audioPlayer.stop(true);
      if (this.voiceConnection.state.status !== import_voice4.VoiceConnectionStatus.Destroyed)
        this.voiceConnection.destroy();
    } catch {
    }
  }
  end() {
    try {
      this.audioPlayer.stop();
    } catch {
    }
  }
  pause(interpolateSilence) {
    const success = this.audioPlayer.pause(interpolateSilence);
    return success;
  }
  resume() {
    const success = this.audioPlayer.unpause();
    return success;
  }
  async playStream(resource = this.audioResource) {
    if (!resource)
      throw new PlayerError("Audio resource is not available!", "NoAudioResource" /* NO_AUDIO_RESOURCE */);
    if (resource.ended) {
      return void this.emit("finish", resource);
    }
    if (!this.audioResource)
      this.audioResource = resource;
    if (this.voiceConnection.state.status !== import_voice4.VoiceConnectionStatus.Ready) {
      try {
        await (0, import_voice4.entersState)(this.voiceConnection, import_voice4.VoiceConnectionStatus.Ready, this.connectionTimeout);
      } catch (err) {
        return void this.emit("error", err);
      }
    }
    try {
      this.audioPlayer.play(resource);
    } catch (e) {
      this.emit("error", e);
    }
    return this;
  }
  setVolume(value) {
    if (!this.dsp.volume)
      return false;
    return this.dsp.volume.setVolume(value);
  }
  get volume() {
    if (!this.dsp.volume)
      return 100;
    return this.dsp.volume.volume;
  }
  get streamTime() {
    if (!this.audioResource)
      return 0;
    return this.audioResource.playbackDuration;
  }
};
__name(StreamDispatcher, "StreamDispatcher");

// src/VoiceInterface/VoiceUtils.ts
var import_utils8 = require("@discord-player/utils");
var VoiceUtils = class {
  constructor(player) {
    this.player = player;
    this.cache = new import_utils8.Collection();
  }
  async connect(channel, options) {
    if (!options?.queue)
      throw new Error("GuildQueue is required");
    const conn = await this.join(channel, options);
    const sub = new StreamDispatcher(conn, channel, options.queue, options.maxTime);
    this.cache.set(channel.guild.id, sub);
    return sub;
  }
  async join(channel, options) {
    const conn = (0, import_voice5.joinVoiceChannel)({
      guildId: channel.guild.id,
      channelId: channel.id,
      adapterCreator: channel.guild.voiceAdapterCreator,
      selfDeaf: Boolean(options?.deaf),
      debug: this.player.events.eventNames().includes("debug")
    });
    return conn;
  }
  disconnect(connection) {
    if (connection instanceof StreamDispatcher)
      connection = connection.voiceConnection;
    try {
      if (connection.state.status !== import_voice5.VoiceConnectionStatus.Destroyed)
        return connection.destroy();
    } catch {
    }
  }
  getConnection(guild) {
    return this.cache.get(guild) || (0, import_voice5.getVoiceConnection)(guild);
  }
};
__name(VoiceUtils, "VoiceUtils");

// src/utils/QueryCache.ts
var DEFAULT_EXPIRY_TIMEOUT = 18e6;
var _defaultCache;
var QueryCache = class {
  constructor(player, options = {
    checkInterval: DEFAULT_EXPIRY_TIMEOUT
  }) {
    this.player = player;
    this.options = options;
    __privateAdd(this, _defaultCache, /* @__PURE__ */ new Map());
    this.timer = setInterval(this.cleanup.bind(this), this.checkInterval).unref();
  }
  get checkInterval() {
    return this.options.checkInterval ?? DEFAULT_EXPIRY_TIMEOUT;
  }
  async cleanup() {
    for (const [id, value] of __privateGet(this, _defaultCache)) {
      if (value.hasExpired()) {
        __privateGet(this, _defaultCache).delete(id);
      }
    }
  }
  async clear() {
    __privateGet(this, _defaultCache).clear();
  }
  async getData() {
    return [...__privateGet(this, _defaultCache).values()];
  }
  async addData(data) {
    data.tracks.forEach((d) => {
      if (__privateGet(this, _defaultCache).has(d.url))
        return;
      __privateGet(this, _defaultCache).set(d.url, new DiscordPlayerQueryResultCache(d));
    });
  }
  async resolve(context) {
    const result = __privateGet(this, _defaultCache).get(context.query);
    if (!result)
      return new SearchResult(this.player, {
        query: context.query,
        requestedBy: context.requestedBy,
        queryType: context.queryType
      });
    return new SearchResult(this.player, {
      query: context.query,
      tracks: [result.data],
      playlist: null,
      queryType: context.queryType,
      requestedBy: context.requestedBy
    });
  }
};
__name(QueryCache, "QueryCache");
_defaultCache = new WeakMap();
var DiscordPlayerQueryResultCache = class {
  constructor(data, expireAfter = DEFAULT_EXPIRY_TIMEOUT) {
    this.data = data;
    this.expireAfter = DEFAULT_EXPIRY_TIMEOUT;
    if (typeof expireAfter === "number") {
      this.expireAfter = Date.now() + expireAfter;
    }
  }
  hasExpired() {
    if (typeof this.expireAfter !== "number" || isNaN(this.expireAfter) || this.expireAfter < 1)
      return false;
    return Date.now() <= this.expireAfter;
  }
};
__name(DiscordPlayerQueryResultCache, "DiscordPlayerQueryResultCache");

// src/Player.ts
var import_discord3 = require("discord.js");
var import_voice6 = require("@discordjs/voice");
var kSingleton = Symbol("InstanceDiscordPlayerSingleton");
var _lastLatency, _voiceStateUpdateListener, _lagMonitorTimeout, _lagMonitorInterval;
var _Player = class extends PlayerEventsEmitter {
  constructor(client, options = {}) {
    if (!options.ignoreInstance && kSingleton in _Player)
      return _Player[kSingleton];
    super(["error"]);
    __privateAdd(this, _lastLatency, -1);
    __privateAdd(this, _voiceStateUpdateListener, this.handleVoiceState.bind(this));
    __privateAdd(this, _lagMonitorTimeout, void 0);
    __privateAdd(this, _lagMonitorInterval, void 0);
    this.id = import_discord3.SnowflakeUtil.generate().toString();
    this.nodes = new GuildNodeManager(this);
    this.voiceUtils = new VoiceUtils(this);
    this.extractors = new ExtractorExecutionContext(this);
    this.events = new PlayerEventsEmitter(["error", "playerError"]);
    this.client = client;
    if (this.client?.options?.intents && !new import_discord3.IntentsBitField(this.client?.options?.intents).has(import_discord3.IntentsBitField.Flags.GuildVoiceStates)) {
      Util.warn('client is missing "GuildVoiceStates" intent', "InvalidIntentsBitField");
    }
    this.options = {
      autoRegisterExtractor: true,
      lockVoiceStateHandler: false,
      blockExtractors: [],
      blockStreamFrom: [],
      connectionTimeout: 2e4,
      smoothVolume: true,
      lagMonitor: 3e4,
      queryCache: options.queryCache === null ? null : new QueryCache(this),
      ...options,
      ytdlOptions: {
        highWaterMark: 1 << 25,
        ...options.ytdlOptions
      }
    };
    this.client.on("voiceStateUpdate", __privateGet(this, _voiceStateUpdateListener));
    if (this.options?.autoRegisterExtractor) {
      this.extractors.loadDefault().then((r) => {
        if (r.error) {
          this.emit("error", new Error(`Failed to load default extractors: ${r.error?.stack ?? r.error}`));
        } else {
          this.debug("Default extractors loaded!");
        }
        this.debug(`[Dependencies Report]
${this.scanDeps()}`);
      });
    }
    if (typeof this.options.lagMonitor === "number" && this.options.lagMonitor > 0) {
      __privateSet(this, _lagMonitorInterval, setInterval(() => {
        const start = performance.now();
        __privateSet(this, _lagMonitorTimeout, setTimeout(() => {
          __privateSet(this, _lastLatency, performance.now() - start);
          this.debug(`[Lag Monitor] Event loop latency: ${__privateGet(this, _lastLatency)}ms`);
        }, 0).unref());
      }, this.options.lagMonitor).unref());
    }
    addPlayer(this);
    if (!(kSingleton in _Player)) {
      Object.defineProperty(_Player, kSingleton, {
        value: this,
        writable: true,
        configurable: true,
        enumerable: false
      });
    }
  }
  debug(m) {
    return this.emit("debug", m);
  }
  static singleton(client, options = {}) {
    return new _Player(client, {
      ...options,
      ignoreInstance: false
    });
  }
  static getAllPlayers() {
    return getPlayers();
  }
  static clearAllPlayers() {
    return instances.clear();
  }
  get queryCache() {
    return this.options.queryCache ?? null;
  }
  get queues() {
    return this.nodes;
  }
  get eventLoopLag() {
    return __privateGet(this, _lastLatency);
  }
  generateStatistics() {
    return {
      instances: instances.size,
      queuesCount: this.queues.cache.size,
      queryCacheEnabled: this.queryCache != null,
      queues: this.queues.cache.map((m) => m.stats.generate())
    };
  }
  async destroy() {
    this.nodes.cache.forEach((node) => node.delete());
    this.client.off("voiceStateUpdate", __privateGet(this, _voiceStateUpdateListener));
    this.removeAllListeners();
    this.events.removeAllListeners();
    await this.extractors.unregisterAll();
    if (__privateGet(this, _lagMonitorInterval))
      clearInterval(__privateGet(this, _lagMonitorInterval));
    if (__privateGet(this, _lagMonitorTimeout))
      clearInterval(__privateGet(this, _lagMonitorTimeout));
    clearPlayer(this);
  }
  _handleVoiceState(oldState, newState) {
    const queue = this.nodes.get(oldState.guild.id);
    if (!queue || !queue.connection || !queue.channel)
      return;
    const wasHandled = this.events.emit("voiceStateUpdate", queue, oldState, newState);
    if (wasHandled && !this.options.lockVoiceStateHandler)
      return;
    if (oldState.channelId && !newState.channelId && newState.member?.id === newState.guild.members.me?.id) {
      try {
        queue.delete();
      } catch {
      }
      return void this.events.emit("disconnect", queue);
    }
    if (!oldState.channelId && newState.channelId && newState.member?.id === newState.guild.members.me?.id) {
      if (newState.serverMute != null && oldState.serverMute !== newState.serverMute) {
        queue.node.setPaused(newState.serverMute);
      } else if (newState.channel?.type === import_discord3.ChannelType.GuildStageVoice && newState.suppress != null && oldState.suppress !== newState.suppress) {
        queue.node.setPaused(newState.suppress);
        if (newState.suppress) {
          newState.guild.members.me?.voice.setRequestToSpeak(true).catch(Util.noop);
        }
      }
    }
    if (!newState.channelId && oldState.channelId === queue.channel.id) {
      if (!Util.isVoiceEmpty(queue.channel))
        return;
      const timeout = setTimeout(() => {
        if (!Util.isVoiceEmpty(queue.channel))
          return;
        if (!this.nodes.has(queue.guild.id))
          return;
        if (queue.options.leaveOnEmpty)
          queue.delete();
        this.events.emit("emptyChannel", queue);
      }, queue.options.leaveOnEmptyCooldown || 0).unref();
      queue.timeouts.set(`empty_${oldState.guild.id}`, timeout);
    }
    if (newState.channelId && newState.channelId === queue.channel.id) {
      const emptyTimeout = queue.timeouts.get(`empty_${oldState.guild.id}`);
      const channelEmpty = Util.isVoiceEmpty(queue.channel);
      if (!channelEmpty && emptyTimeout) {
        clearTimeout(emptyTimeout);
        queue.timeouts.delete(`empty_${oldState.guild.id}`);
      }
    }
    if (oldState.channelId && newState.channelId && oldState.channelId !== newState.channelId) {
      if (newState.member?.id === newState.guild.members.me?.id) {
        if (queue.connection && newState.member?.id === newState.guild.members.me?.id)
          queue.channel = newState.channel;
        const emptyTimeout = queue.timeouts.get(`empty_${oldState.guild.id}`);
        const channelEmpty = Util.isVoiceEmpty(queue.channel);
        if (!channelEmpty && emptyTimeout) {
          clearTimeout(emptyTimeout);
          queue.timeouts.delete(`empty_${oldState.guild.id}`);
        } else {
          const timeout = setTimeout(() => {
            if (queue.connection && !Util.isVoiceEmpty(queue.channel))
              return;
            if (!this.nodes.has(queue.guild.id))
              return;
            if (queue.options.leaveOnEmpty)
              queue.delete();
            this.events.emit("emptyChannel", queue);
          }, queue.options.leaveOnEmptyCooldown || 0).unref();
          queue.timeouts.set(`empty_${oldState.guild.id}`, timeout);
        }
      } else {
        if (newState.channelId !== queue.channel.id) {
          if (!Util.isVoiceEmpty(queue.channel))
            return;
          if (queue.timeouts.has(`empty_${oldState.guild.id}`))
            return;
          const timeout = setTimeout(() => {
            if (!Util.isVoiceEmpty(queue.channel))
              return;
            if (!this.nodes.has(queue.guild.id))
              return;
            if (queue.options.leaveOnEmpty)
              queue.delete();
            this.events.emit("emptyChannel", queue);
          }, queue.options.leaveOnEmptyCooldown || 0).unref();
          queue.timeouts.set(`empty_${oldState.guild.id}`, timeout);
        } else {
          const emptyTimeout = queue.timeouts.get(`empty_${oldState.guild.id}`);
          const channelEmpty = Util.isVoiceEmpty(queue.channel);
          if (!channelEmpty && emptyTimeout) {
            clearTimeout(emptyTimeout);
            queue.timeouts.delete(`empty_${oldState.guild.id}`);
          }
        }
      }
    }
  }
  handleVoiceState(oldState, newState) {
    this._handleVoiceState(oldState, newState);
  }
  lockVoiceStateHandler() {
    this.options.lockVoiceStateHandler = true;
  }
  unlockVoiceStateHandler() {
    this.options.lockVoiceStateHandler = false;
  }
  isVoiceStateHandlerLocked() {
    return !!this.options.lockVoiceStateHandler;
  }
  async play(channel, query, options = {}) {
    const vc = this.client.channels.resolve(channel);
    if (!vc?.isVoiceBased())
      throw new Error("Expected a voice channel");
    const originalResult = query instanceof SearchResult ? query : await this.search(query, options);
    const result = await options.afterSearch?.(originalResult) || originalResult;
    if (result.isEmpty()) {
      throw new Error(`No results found for "${query}" (Extractor: ${result.extractor?.identifier || "N/A"})`);
    }
    const queue = this.nodes.create(vc.guild, options.nodeOptions);
    if (!queue.channel)
      await queue.connect(vc, options.connectionOptions);
    if (!result.playlist) {
      queue.addTrack(result.tracks[0]);
    } else {
      queue.addTrack(result.playlist);
    }
    if (!queue.isPlaying())
      await queue.node.play();
    return {
      track: result.tracks[0],
      extractor: result.extractor,
      searchResult: result,
      queue
    };
  }
  async search(query, options = {}) {
    if (query instanceof SearchResult)
      return query;
    if (options.requestedBy != null)
      options.requestedBy = this.client.users.resolve(options.requestedBy);
    options.blockExtractors ?? (options.blockExtractors = this.options.blockExtractors);
    options.fallbackSearchEngine ?? (options.fallbackSearchEngine = QueryType.AUTO_SEARCH);
    if (query instanceof Track) {
      return new SearchResult(this, {
        playlist: query.playlist || null,
        tracks: [query],
        query: query.title,
        extractor: query.extractor,
        queryType: query.queryType,
        requestedBy: options.requestedBy
      });
    }
    if (query instanceof Playlist) {
      return new SearchResult(this, {
        playlist: query,
        tracks: query.tracks,
        query: query.title,
        extractor: query.tracks[0]?.extractor,
        queryType: QueryType.AUTO,
        requestedBy: options.requestedBy
      });
    }
    if (Array.isArray(query)) {
      const tracks = query.filter((t) => t instanceof Track);
      return new SearchResult(this, {
        playlist: null,
        tracks,
        query: "@@#%{{UserLoadedContent}}%#@@",
        extractor: null,
        queryType: QueryType.AUTO,
        requestedBy: options.requestedBy
      });
    }
    this.debug(`Searching ${query}`);
    let extractor = null;
    options.searchEngine ?? (options.searchEngine = QueryType.AUTO);
    this.debug(`Search engine set to ${options.searchEngine}`);
    const queryType = options.searchEngine === QueryType.AUTO ? QueryResolver.resolve(query, options.fallbackSearchEngine) : options.searchEngine;
    this.debug(`Query type identified as ${queryType}`);
    if (options.searchEngine.startsWith("ext:")) {
      extractor = this.extractors.get(options.searchEngine.substring(4));
      if (!extractor)
        return new SearchResult(this, {
          query,
          queryType,
          extractor,
          requestedBy: options.requestedBy
        });
    }
    if (!extractor) {
      if (!options.ignoreCache) {
        this.debug(`Checking cache...`);
        const res2 = await this.queryCache?.resolve({
          query,
          queryType,
          requestedBy: options.requestedBy
        });
        if (res2?.hasTracks()) {
          this.debug(`Cache hit for query ${query}`);
          return res2;
        }
        this.debug(`Cache miss for query ${query}`);
      }
      this.debug(`Executing extractors...`);
      extractor = (await this.extractors.run(async (ext) => {
        if (options.blockExtractors?.includes(ext.identifier))
          return false;
        return ext.validate(query, queryType);
      }))?.extractor || null;
    }
    if (!extractor) {
      this.debug("Failed to find appropriate extractor");
      return new SearchResult(this, {
        query,
        queryType,
        requestedBy: options.requestedBy
      });
    }
    this.debug(`Executing metadata query using ${extractor.identifier} extractor...`);
    const res = await extractor.handle(query, {
      type: queryType,
      requestedBy: options.requestedBy
    }).catch(() => null);
    if (res) {
      this.debug("Metadata query was successful!");
      const result2 = new SearchResult(this, {
        query,
        queryType,
        playlist: res.playlist,
        tracks: res.tracks,
        extractor,
        requestedBy: options.requestedBy
      });
      if (!options.ignoreCache) {
        this.debug(`Adding data to cache...`);
        await this.queryCache?.addData(result2);
      }
      return result2;
    }
    this.debug("Failed to find result using appropriate extractor. Querying all extractors...");
    const result = await this.extractors.run(
      async (ext) => !options.blockExtractors?.includes(ext.identifier) && await ext.validate(query) && ext.handle(query, {
        type: queryType,
        requestedBy: options.requestedBy
      })
    );
    if (!result?.result) {
      this.debug(`Failed to query metadata query using ${result?.extractor.identifier || "N/A"} extractor.`);
      return new SearchResult(this, {
        query,
        queryType,
        requestedBy: options.requestedBy,
        extractor: result?.extractor
      });
    }
    this.debug(`Metadata query was successful using ${result.extractor.identifier}!`);
    const data = new SearchResult(this, {
      query,
      queryType,
      playlist: result.result.playlist,
      tracks: result.result.tracks,
      extractor: result.extractor,
      requestedBy: options.requestedBy
    });
    if (!options.ignoreCache) {
      this.debug(`Adding data to cache...`);
      await this.queryCache?.addData(data);
    }
    return data;
  }
  scanDeps() {
    const line = "-".repeat(50);
    const depsReport = (0, import_voice6.generateDependencyReport)();
    const extractorReport = this.extractors.store.map((m) => {
      return m.identifier;
    }).join("\n");
    return `${depsReport}
Loaded Extractors:
${extractorReport || "None"}
${line}`;
  }
  *[Symbol.iterator]() {
    yield* this.nodes.cache.values();
  }
  createPlaylist(data) {
    return new Playlist(this, data);
  }
};
var Player = _Player;
__name(Player, "Player");
_lastLatency = new WeakMap();
_voiceStateUpdateListener = new WeakMap();
_lagMonitorTimeout = new WeakMap();
_lagMonitorInterval = new WeakMap();
Player._singletonKey = kSingleton;

// src/hooks/common.ts
var getPlayer = /* @__PURE__ */ __name(() => {
  return instances.first() || null;
}, "getPlayer");
var getQueue = /* @__PURE__ */ __name((node) => {
  const player = getPlayer();
  if (!player)
    return null;
  return player.nodes.resolve(node) || null;
}, "getQueue");

// src/hooks/useHistory.ts
function useHistory(node) {
  const queue = getQueue(node);
  if (!queue)
    return null;
  return queue.history;
}
__name(useHistory, "useHistory");

// src/hooks/usePlayer.ts
function usePlayer(node) {
  const queue = getQueue(node);
  if (!queue)
    return null;
  return queue.node;
}
__name(usePlayer, "usePlayer");

// src/hooks/useQueue.ts
function useQueue(node) {
  const queue = getQueue(node);
  if (!queue)
    return null;
  return queue;
}
__name(useQueue, "useQueue");

// src/hooks/useMasterPlayer.ts
function useMasterPlayer() {
  return getPlayer();
}
__name(useMasterPlayer, "useMasterPlayer");

// src/hooks/useMetadata.ts
function useMetadata(node) {
  const queue = getQueue(node);
  const setter = /* @__PURE__ */ __name((metadata) => {
    if (queue) {
      queue.setMetadata(metadata);
    }
  }, "setter");
  const getter = /* @__PURE__ */ __name(() => {
    return queue?.metadata;
  }, "getter");
  return [getter, setter];
}
__name(useMetadata, "useMetadata");

// src/hooks/useTimestamp.ts
function useTimeline(node, options) {
  const queue = getQueue(node);
  if (!queue)
    return null;
  return Object.preventExtensions({
    get timestamp() {
      return queue.node.getTimestamp(options?.ignoreFilters);
    },
    get volume() {
      return queue.node.volume;
    },
    get paused() {
      return queue.node.isPaused();
    },
    pause() {
      return queue.node.pause();
    },
    resume() {
      return queue.node.resume();
    },
    setVolume(vol) {
      return queue.node.setVolume(vol);
    },
    async setPosition(time) {
      return queue.node.seek(time);
    }
  });
}
__name(useTimeline, "useTimeline");

// src/hooks/stream/onAfterCreateStream.ts
function onAfterCreateStream(handler) {
  getGlobalRegistry().set("@[onAfterCreateStream]", handler);
}
__name(onAfterCreateStream, "onAfterCreateStream");

// src/hooks/stream/onBeforeCreateStream.ts
function onBeforeCreateStream(handler) {
  getGlobalRegistry().set("@[onBeforeCreateStream]", handler);
}
__name(onBeforeCreateStream, "onBeforeCreateStream");

// src/index.ts
var import_equalizer3 = require("@discord-player/equalizer");
var version2 = "6.1.1";
if (!import_discord4.version.startsWith("14")) {
  process.emitWarning(`Discord.js v${import_discord4.version} is incompatible with Discord Player v${version2}! Please use >=v14.x of Discord.js`);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AF_NIGHTCORE_RATE,
  AF_VAPORWAVE_RATE,
  AFilterGraph,
  AudioFilters,
  BASS_EQ_BANDS,
  BaseExtractor,
  BiquadFilterType,
  DiscordPlayerQueryResultCache,
  EqualizerConfigurationPreset,
  ErrorStatusCode,
  ExtractorExecutionContext,
  FFMPEG_ARGS_PIPED,
  FFMPEG_ARGS_STRING,
  FFMPEG_SRATE_REGEX,
  FFmpegFilterer,
  FiltersChain,
  GuildNodeManager,
  GuildQueue,
  GuildQueueAudioFilters,
  GuildQueueEvent,
  GuildQueueHistory,
  GuildQueuePlayerNode,
  PCMAudioFilters,
  Player,
  PlayerError,
  PlayerEvent,
  PlayerEventsEmitter,
  Playlist,
  Q_BUTTERWORTH,
  QueryCache,
  QueryResolver,
  QueryType,
  QueueRepeatMode,
  SearchResult,
  StreamDispatcher,
  Track,
  TypeUtil,
  Util,
  VoiceReceiverNode,
  VoiceUtils,
  VolumeTransformer,
  createFFmpegStream,
  onAfterCreateStream,
  onBeforeCreateStream,
  useHistory,
  useMasterPlayer,
  useMetadata,
  usePlayer,
  useQueue,
  useTimeline,
  version
});
//# sourceMappingURL=index.js.map