import { ListenerSignature, DefaultListener, EventEmitter, Collection, Queue, QueueStrategy } from '@discord-player/utils';
import * as discord_js from 'discord.js';
import { User, VoiceChannel, StageChannel, UserResolvable, Guild, VoiceState, VoiceBasedChannel, GuildVoiceChannelResolvable, Snowflake, Client, GuildResolvable } from 'discord.js';
import * as _discordjs_voice from '@discordjs/voice';
import { AudioPlayerError, AudioResource, VoiceConnection, AudioPlayer, AudioPlayerStatus, StreamType, EndBehaviorType } from '@discordjs/voice';
import { Readable, Duplex } from 'stream';
import * as _discord_player_equalizer from '@discord-player/equalizer';
import { PCMFilters, EqualizerBand, BiquadFilters, FiltersChain } from '@discord-player/equalizer';
export { AF_NIGHTCORE_RATE, AF_VAPORWAVE_RATE, BASS_EQ_BANDS, FilterType as BiquadFilterType, BiquadFilters, FiltersChain, AudioFilters as PCMAudioFilters, PCMFilters, Q_BUTTERWORTH, VolumeTransformer } from '@discord-player/equalizer';
import { RequestOptions } from 'http';
import { downloadOptions } from 'ytdl-core';

declare class PlayerEventsEmitter<L extends ListenerSignature<L> = DefaultListener> extends EventEmitter<L> {
    requiredEvents: Array<keyof L>;
    constructor(requiredEvents?: Array<keyof L>);
    emit<K extends keyof L>(name: K, ...args: Parameters<L[K]>): boolean;
}

declare class Playlist {
    readonly player: Player;
    tracks: Track[];
    title: string;
    description: string;
    thumbnail: string;
    type: 'album' | 'playlist';
    source: TrackSource;
    author: {
        name: string;
        url: string;
    };
    id: string;
    url: string;
    readonly rawPlaylist?: any;
    /**
     * Playlist constructor
     * @param {Player} player The player
     * @param {PlaylistInitData} data The data
     */
    constructor(player: Player, data: PlaylistInitData);
    [Symbol.iterator](): Generator<Track, void, undefined>;
    /**
     * Estimated duration of this playlist
     */
    get estimatedDuration(): number;
    /**
     * Formatted estimated duration of this playlist
     */
    get durationFormatted(): string;
    /**
     * JSON representation of this playlist
     * @param {boolean} [withTracks=true] If it should build json with tracks
     * @returns {PlaylistJSON}
     */
    toJSON(withTracks?: boolean): PlaylistJSON;
}

interface ExtractorExecutionEvents {
    /**
     * Emitted when a extractor is registered
     * @param context The context where extractor was registered
     * @param extractor The extractor that was registered
     */
    registered: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;
    /**
     * Emitted when a extractor is unregistered
     * @param context The context where extractor was unregistered
     * @param extractor The extractor that was unregistered
     */
    unregistered: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;
    /**
     * Emitted when a extractor is activated
     * @param context The context where this event occurred
     * @param extractor The extractor which was activated
     */
    activate: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;
    /**
     * Emitted when a extractor is deactivated
     * @param context The context where this event occurred
     * @param extractor The extractor which was deactivated
     */
    deactivate: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;
    /**
     * Emitted when a extractor fails to activate/deactivate
     * @param context The context where this event occurred
     * @param extractor The extractor which was deactivated
     */
    error: (context: ExtractorExecutionContext, extractor: BaseExtractor, error: Error) => unknown;
}
declare class ExtractorExecutionContext extends PlayerEventsEmitter<ExtractorExecutionEvents> {
    player: Player;
    store: Collection<string, BaseExtractor>;
    constructor(player: Player);
    /**
     * Load default extractors from `@discord-player/extractor`
     */
    loadDefault(): Promise<{
        success: boolean;
        error: Error;
    } | {
        success: boolean;
        error: null;
    }>;
    /**
     * Validate if the given extractor is registered
     * @param identifier The extractor identifier
     */
    isRegistered(identifier: string): boolean;
    /**
     * The size of registered extractors
     */
    get size(): number;
    /**
     * Get single extractor
     * @param identifier The extractor to get
     */
    get(identifier: string): BaseExtractor | undefined;
    /**
     * Register single extractor
     * @param _extractor The extractor to register
     * @param options Options supplied to the extractor
     */
    register(_extractor: typeof BaseExtractor, options?: Record<string, unknown>): Promise<void>;
    /**
     * Unregister single extractor
     * @param _extractor The extractor to unregister
     */
    unregister<K extends string | BaseExtractor>(_extractor: K): Promise<void>;
    /**
     * Unregister all extractors
     */
    unregisterAll(): Promise<void>;
    /**
     * Run all the extractors
     * @param fn The runner function
     * @param filterBlocked Filter blocked extractors
     */
    run<T = unknown>(fn: ExtractorExecutionFN<T>, filterBlocked?: boolean): Promise<ExtractorExecutionResult<T> | null>;
}
interface ExtractorExecutionResult<T = unknown> {
    extractor: BaseExtractor;
    result: T;
}
type ExtractorExecutionFN<T = unknown> = (extractor: BaseExtractor) => Promise<T | boolean>;

declare class BaseExtractor {
    context: ExtractorExecutionContext;
    options: Record<string, unknown>;
    /**
     * Identifier for this extractor
     */
    static identifier: string;
    /**
     * Extractor constructor
     * @param context Context that instantiated this extractor
     * @param options Initialization options for this extractor
     */
    constructor(context: ExtractorExecutionContext, options?: Record<string, unknown>);
    /**
     * Identifier of this extractor
     */
    get identifier(): string;
    /**
     * This method will be executed when this extractor is activated
     */
    activate(): Promise<void>;
    /**
     * This method will be executed when this extractor is deactivated
     */
    deactivate(): Promise<void>;
    /**
     * Validate incoming query
     * @param query The query to validate
     */
    validate(query: string, type?: SearchQueryType | null): Promise<boolean>;
    /**
     * Stream the given track
     * @param info The track to stream
     */
    stream(info: Track): Promise<Readable | string>;
    /**
     * Handle the given query
     * @param query The query to handle
     */
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    /**
     * Get related tracks for the given track
     * @param track The track source
     */
    getRelatedTracks(track: Track): Promise<ExtractorInfo>;
    /**
     * A stream middleware to handle streams before passing it to the player
     * @param stream The incoming stream
     * @param next The next function
     */
    handlePostStream(stream: Readable, next: NextFunction): void;
    /**
     * Dispatch an event to the player
     * @param event The event to dispatch
     * @param args The data to dispatch
     */
    emit<K extends keyof PlayerEvents>(event: K, ...args: Parameters<PlayerEvents[K]>): boolean;
    /**
     * Create extractor response
     * @param playlist The playlist
     * @param tracks The track array
     */
    createResponse(playlist?: Playlist | null, tracks?: Track[]): ExtractorInfo;
    /**
     * Write debug message
     * @param message The debug message
     */
    debug(message: string): boolean;
}
type NextFunction = (error?: Error | null, stream?: Readable) => void;
interface ExtractorInfo {
    playlist: Playlist | null;
    tracks: Track[];
}
interface ExtractorSearchContext {
    type?: SearchQueryType | null;
    requestedBy?: User | null;
    requestOptions?: RequestOptions;
}

type TrackResolvable = Track | string | number;
declare class Track {
    player: Player;
    title: string;
    description: string;
    author: string;
    url: string;
    thumbnail: string;
    duration: string;
    views: number;
    requestedBy: User | null;
    playlist?: Playlist;
    queryType: SearchQueryType | null | undefined;
    raw: RawTrackData;
    extractor: BaseExtractor | null;
    readonly id: string;
    /**
     * Track constructor
     * @param {Player} player The player that instantiated this Track
     * @param {RawTrackData} data Track data
     */
    constructor(player: Player, data: RawTrackData);
    private _patch;
    /**
     * The queue in which this track is located
     * @type {Queue}
     */
    get queue(): GuildQueue;
    /**
     * The track duration in millisecond
     * @type {number}
     */
    get durationMS(): number;
    /**
     * Returns source of this track
     * @type {TrackSource}
     */
    get source(): TrackSource;
    /**
     * String representation of this track
     * @returns {string}
     */
    toString(): string;
    /**
     * Raw JSON representation of this track
     * @returns {TrackJSON}
     */
    toJSON(hidePlaylist?: boolean): TrackJSON;
}

interface CreateStreamOps {
    type?: StreamType;
    data?: any;
    disableVolume?: boolean;
    disableEqualizer?: boolean;
    disableBiquad?: boolean;
    eq?: EqualizerBand[];
    biquadFilter?: BiquadFilters;
    disableFilters?: boolean;
    defaultFilters?: PCMFilters[];
    volume?: number;
    disableResampler?: boolean;
    sampleRate?: number;
}
interface VoiceEvents {
    error: (error: AudioPlayerError) => any;
    debug: (message: string) => any;
    start: (resource: AudioResource<Track>) => any;
    finish: (resource: AudioResource<Track>) => any;
    dsp: (filters: PCMFilters[]) => any;
    eqBands: (filters: EqualizerBand[]) => any;
    sampleRate: (filters: number) => any;
    biquad: (filters: BiquadFilters) => any;
    volume: (volume: number) => any;
}
declare class StreamDispatcher extends EventEmitter<VoiceEvents> {
    queue: GuildQueue;
    readonly connectionTimeout: number;
    readonly voiceConnection: VoiceConnection;
    readonly audioPlayer: AudioPlayer;
    receiver: VoiceReceiverNode;
    channel: VoiceChannel | StageChannel;
    audioResource?: AudioResource<Track> | null;
    private readyLock;
    dsp: FiltersChain;
    /**
     * Creates new connection object
     * @param {VoiceConnection} connection The connection
     * @param {VoiceChannel|StageChannel} channel The connected channel
     * @private
     */
    constructor(connection: VoiceConnection, channel: VoiceChannel | StageChannel, queue: GuildQueue, connectionTimeout?: number);
    /**
     * Check if the player has been paused manually
     */
    get paused(): boolean;
    set paused(val: boolean);
    /**
     * Whether or not the player is currently paused automatically or manually.
     */
    isPaused(): boolean;
    /**
     * Whether or not the player is currently buffering
     */
    isBuffering(): boolean;
    /**
     * Whether or not the player is currently playing
     */
    isPlaying(): boolean;
    /**
     * Whether or not the player is currently idle
     */
    isIdle(): boolean;
    /**
     * Whether or not the voice connection has been destroyed
     */
    isDestroyed(): boolean;
    /**
     * Whether or not the voice connection has been destroyed
     */
    isDisconnected(): boolean;
    /**
     * Whether or not the voice connection is ready to play
     */
    isReady(): boolean;
    /**
     * Whether or not the voice connection is signalling
     */
    isSignalling(): boolean;
    /**
     * Whether or not the voice connection is connecting
     */
    isConnecting(): boolean;
    /**
     * Creates stream
     * @param {Readable} src The stream source
     * @param {object} [ops] Options
     * @returns {AudioResource}
     */
    createStream(src: Readable, ops?: CreateStreamOps): Promise<AudioResource<Track>>;
    get resampler(): _discord_player_equalizer.PCMResampler | null;
    get filters(): _discord_player_equalizer.AudioFilter | null;
    get biquad(): _discord_player_equalizer.BiquadStream | null;
    get equalizer(): _discord_player_equalizer.EqualizerStream | null;
    /**
     * The player status
     * @type {AudioPlayerStatus}
     */
    get status(): AudioPlayerStatus;
    /**
     * Disconnects from voice
     * @returns {void}
     */
    disconnect(): void;
    /**
     * Stops the player
     * @returns {void}
     */
    end(): void;
    /**
     * Pauses the stream playback
     * @param {boolean} [interpolateSilence=false] If true, the player will play 5 packets of silence after pausing to prevent audio glitches.
     * @returns {boolean}
     */
    pause(interpolateSilence?: boolean): boolean;
    /**
     * Resumes the stream playback
     * @returns {boolean}
     */
    resume(): boolean;
    /**
     * Play stream
     * @param {AudioResource<Track>} [resource=this.audioResource] The audio resource to play
     * @returns {Promise<StreamDispatcher>}
     */
    playStream(resource?: AudioResource<Track>): Promise<this | undefined>;
    /**
     * Sets playback volume
     * @param {number} value The volume amount
     * @returns {boolean}
     */
    setVolume(value: number): boolean;
    /**
     * The current volume
     * @type {number}
     */
    get volume(): number;
    /**
     * The playback time
     * @type {number}
     */
    get streamTime(): number;
}

interface VoiceReceiverOptions {
    mode?: 'opus' | 'pcm';
    end?: EndBehaviorType;
    silenceDuration?: number;
    crc?: boolean;
}
type RawTrackInit = Partial<Omit<RawTrackData, 'author' | 'playlist' | 'source' | 'engine' | 'raw' | 'queryType' | 'description' | 'views'>>;
declare class VoiceReceiverNode {
    dispatcher: StreamDispatcher;
    constructor(dispatcher: StreamDispatcher);
    createRawTrack(stream: Readable, data?: RawTrackInit): Track;
    /**
     * Merge multiple streams together
     * @param streams The array of streams to merge
     */
    mergeRecordings(streams: Readable[]): void;
    /**
     * Record a user in voice channel
     * @param user The user to record
     * @param options Recording options
     */
    recordUser(user: UserResolvable, options?: VoiceReceiverOptions): Readable;
}

declare class GuildQueueHistory<Meta = unknown> {
    queue: GuildQueue<Meta>;
    tracks: Queue<Track>;
    constructor(queue: GuildQueue<Meta>);
    /**
     * Current track in the queue
     */
    get currentTrack(): Track | null;
    /**
     * Next track in the queue
     */
    get nextTrack(): Track | null;
    /**
     * Previous track in the queue
     */
    get previousTrack(): Track | null;
    /**
     * If history is disabled
     */
    get disabled(): boolean;
    /**
     * Gets the size of the queue
     */
    get size(): number;
    getSize(): number;
    /**
     * If history is empty
     */
    isEmpty(): boolean;
    /**
     * Add track to track history
     * @param track The track to add
     */
    push(track: Track | Track[]): boolean;
    /**
     * Clear history
     */
    clear(): void;
    /**
     * Play the next track in the queue
     */
    next(): Promise<void>;
    /**
     * Play the previous track in the queue
     */
    previous(preserveCurrent?: boolean): Promise<void>;
    /**
     * Alias to [GuildQueueHistory].previous()
     */
    back(): Promise<void>;
}

declare const FFMPEG_SRATE_REGEX: RegExp;
interface ResourcePlayOptions {
    queue?: boolean;
    seek?: number;
    transitionMode?: boolean;
}
interface PlayerTimestamp {
    current: {
        label: string;
        value: number;
    };
    total: {
        label: string;
        value: number;
    };
    progress: number;
}
declare class GuildQueuePlayerNode<Meta = unknown> {
    #private;
    queue: GuildQueue<Meta>;
    constructor(queue: GuildQueue<Meta>);
    /**
     * If the player is currently in idle mode
     */
    isIdle(): boolean;
    /**
     * If the player is currently buffering the track
     */
    isBuffering(): boolean;
    /**
     * If the player is currently playing a track
     */
    isPlaying(): boolean;
    /**
     * If the player is currently paused
     */
    isPaused(): boolean;
    /**
     * Reset progress history
     */
    resetProgress(): void;
    /**
     * The stream time for current session
     */
    get streamTime(): number;
    /**
     * Current playback duration with history included
     */
    get playbackTime(): number;
    /**
     * Get duration multiplier
     */
    getDurationMultiplier(): number;
    /**
     * Estimated progress of the player
     */
    get estimatedPlaybackTime(): number;
    /**
     * Estimated total duration of the player
     */
    get estimatedDuration(): number;
    /**
     * Get stream progress
     * @param ignoreFilters Ignore filters
     */
    getTimestamp(ignoreFilters?: boolean): PlayerTimestamp | null;
    /**
     * Create progress bar for current progress
     * @param options Progress bar options
     */
    createProgressBar(options?: PlayerProgressbarOptions): string | null;
    /**
     * Seek the player
     * @param duration The duration to seek to
     */
    seek(duration: number): Promise<boolean>;
    /**
     * Current volume
     */
    get volume(): number;
    /**
     * Set volume
     * @param vol Volume amount to set
     */
    setVolume(vol: number): boolean;
    /**
     * Set bit rate
     * @param rate The bit rate to set
     */
    setBitrate(rate: number | 'auto'): void;
    /**
     * Set paused state
     * @param state The state
     */
    setPaused(state: boolean): boolean;
    /**
     * Pause the playback
     */
    pause(): boolean;
    /**
     * Resume the playback
     */
    resume(): boolean;
    /**
     * Skip current track
     */
    skip(): boolean;
    /**
     * Remove the given track from queue
     * @param track The track to remove
     */
    remove(track: TrackResolvable): Track | null;
    /**
     * Jump to specific track on the queue
     * @param track The track to jump to without removing other tracks
     */
    jump(track: TrackResolvable): boolean;
    /**
     * Get track position
     * @param track The track
     */
    getTrackPosition(track: TrackResolvable): number;
    /**
     * Skip to the given track, removing others on the way
     * @param track The track to skip to
     */
    skipTo(track: TrackResolvable): boolean;
    /**
     * Insert a track on the given position in queue
     * @param track The track to insert
     * @param index The position to insert to, defaults to 0.
     */
    insert(track: Track, index?: number): void;
    /**
     * Moves a track in the queue
     * @param from The track to move
     * @param to The position to move to
     */
    move(from: TrackResolvable, to: number): void;
    /**
     * Copy a track in the queue
     * @param from The track to clone
     * @param to The position to clone at
     */
    copy(from: TrackResolvable, to: number): void;
    /**
     * Swap two tracks in the queue
     * @param first The first track to swap
     * @param second The second track to swap
     */
    swap(first: TrackResolvable, second: TrackResolvable): void;
    /**
     * Stop the playback
     * @param force Whether or not to forcefully stop the playback
     */
    stop(force?: boolean): boolean;
    /**
     * Play raw audio resource
     * @param resource The audio resource to play
     */
    playRaw(resource: AudioResource): Promise<void>;
    /**
     * Play the given track
     * @param res The track to play
     * @param options Options for playing the track
     */
    play(res?: Track | null, options?: ResourcePlayOptions): Promise<void>;
}

interface FFmpegStreamOptions {
    fmt?: string;
    encoderArgs?: string[];
    seek?: number;
    skip?: boolean;
    cookies?: string;
}
declare function FFMPEG_ARGS_STRING(stream: string, fmt?: string, cookies?: string): string[];
declare function FFMPEG_ARGS_PIPED(fmt?: string): string[];
/**
 * Creates FFmpeg stream
 * @param stream The source stream
 * @param options FFmpeg stream options
 */
declare function createFFmpegStream(stream: Readable | Duplex | string, options?: FFmpegStreamOptions): Readable;

type Filters = keyof typeof AudioFilters.filters;
declare const EqualizerConfigurationPreset: {
    readonly Flat: EqualizerBand[];
    readonly Classical: EqualizerBand[];
    readonly Club: EqualizerBand[];
    readonly Dance: EqualizerBand[];
    readonly FullBass: EqualizerBand[];
    readonly FullBassTreble: EqualizerBand[];
    readonly FullTreble: EqualizerBand[];
    readonly Headphones: EqualizerBand[];
    readonly LargeHall: EqualizerBand[];
    readonly Live: EqualizerBand[];
    readonly Party: EqualizerBand[];
    readonly Pop: EqualizerBand[];
    readonly Reggae: EqualizerBand[];
    readonly Rock: EqualizerBand[];
    readonly Ska: EqualizerBand[];
    readonly Soft: EqualizerBand[];
    readonly SoftRock: EqualizerBand[];
    readonly Techno: EqualizerBand[];
};
declare class FFmpegFilterer<Meta = unknown> {
    #private;
    af: GuildQueueAudioFilters<Meta>;
    constructor(af: GuildQueueAudioFilters<Meta>);
    /**
     * Create ffmpeg stream
     * @param source The stream source
     * @param options The stream options
     */
    createStream(source: string | Readable, options: FFmpegStreamOptions): Readable;
    /**
     * Set ffmpeg filters
     * @param filters The filters
     */
    setFilters(filters: Filters[] | Record<Filters, boolean> | boolean): Promise<boolean>;
    /**
     * Currently active ffmpeg filters
     */
    get filters(): Filters[];
    set filters(filters: Filters[]);
    /**
     * Toggle given ffmpeg filter(s)
     * @param filters The filter(s)
     */
    toggle(filters: Filters[] | Filters): Promise<boolean>;
    /**
     * Set default filters
     * @param ff Filters list
     */
    setDefaults(ff: Filters[]): void;
    /**
     * Get list of enabled filters
     */
    getFiltersEnabled(): (keyof QueueFilters)[];
    /**
     * Get list of disabled filters
     */
    getFiltersDisabled(): (keyof QueueFilters)[];
    /**
     * Check if the given filter is enabled
     * @param filter The filter
     */
    isEnabled<T extends Filters>(filter: T): boolean;
    /**
     * Check if the given filter is disabled
     * @param filter The filter
     */
    isDisabled<T extends Filters>(filter: T): boolean;
    /**
     * Check if the given filter is a valid filter
     * @param filter The filter to test
     */
    isValidFilter(filter: string): filter is FiltersName;
    /**
     * Convert current filters to array
     */
    toArray(): string[];
    /**
     * Convert current filters to JSON object
     */
    toJSON(): Record<keyof QueueFilters, string>;
    /**
     * String representation of current filters
     */
    toString(): string;
}
interface GuildQueueAFiltersCache {
    equalizer: EqualizerBand[];
    biquad: BiquadFilters | null;
    filters: PCMFilters[];
    volume: number;
    sampleRate: number;
}
declare class GuildQueueAudioFilters<Meta = unknown> {
    queue: GuildQueue<Meta>;
    graph: AFilterGraph<Meta>;
    ffmpeg: FFmpegFilterer<Meta>;
    equalizerPresets: {
        readonly Flat: EqualizerBand[];
        readonly Classical: EqualizerBand[];
        readonly Club: EqualizerBand[];
        readonly Dance: EqualizerBand[];
        readonly FullBass: EqualizerBand[];
        readonly FullBassTreble: EqualizerBand[];
        readonly FullTreble: EqualizerBand[];
        readonly Headphones: EqualizerBand[];
        readonly LargeHall: EqualizerBand[];
        readonly Live: EqualizerBand[];
        readonly Party: EqualizerBand[];
        readonly Pop: EqualizerBand[];
        readonly Reggae: EqualizerBand[];
        readonly Rock: EqualizerBand[];
        readonly Ska: EqualizerBand[];
        readonly Soft: EqualizerBand[];
        readonly SoftRock: EqualizerBand[];
        readonly Techno: EqualizerBand[];
    };
    _lastFiltersCache: GuildQueueAFiltersCache;
    constructor(queue: GuildQueue<Meta>);
    /**
     * Volume transformer
     */
    get volume(): _discord_player_equalizer.VolumeTransformer | null;
    /**
     * 15 Band Equalizer
     */
    get equalizer(): _discord_player_equalizer.EqualizerStream | null;
    /**
     * Digital biquad filters
     */
    get biquad(): _discord_player_equalizer.BiquadStream | null;
    /**
     * DSP filters
     */
    get filters(): _discord_player_equalizer.AudioFilter | null;
    /**
     * Audio resampler
     */
    get resampler(): _discord_player_equalizer.PCMResampler | null;
    /**
     * Replay current track in transition mode
     * @param seek The duration to seek to
     */
    triggerReplay(seek?: number): Promise<boolean>;
}
declare class AFilterGraph<Meta = unknown> {
    af: GuildQueueAudioFilters<Meta>;
    constructor(af: GuildQueueAudioFilters<Meta>);
    get ffmpeg(): (keyof QueueFilters)[];
    get equalizer(): EqualizerBand[];
    get biquad(): null;
    get filters(): ("8D" | "Tremolo" | "Vibrato")[];
    get volume(): _discord_player_equalizer.VolumeTransformer | null;
    get resampler(): _discord_player_equalizer.PCMResampler | null;
    dump(): FilterGraph;
}
interface FilterGraph {
    ffmpeg: Filters[];
    equalizer: EqualizerBand[];
    biquad: Exclude<BiquadFilters, number> | null;
    filters: PCMFilters[];
    volume: number;
    sampleRate: number;
}

interface GuildNodeInit<Meta = unknown> {
    guild: Guild;
    queueStrategy: QueueStrategy;
    equalizer: EqualizerBand[] | boolean;
    volume: number | boolean;
    biquad: BiquadFilters | boolean | undefined;
    resampler: number | boolean;
    filterer: PCMFilters[] | boolean;
    ffmpegFilters: FiltersName[];
    disableHistory: boolean;
    skipOnNoStream: boolean;
    onBeforeCreateStream?: OnBeforeCreateStreamHandler;
    onAfterCreateStream?: OnAfterCreateStreamHandler;
    repeatMode?: QueueRepeatMode;
    leaveOnEmpty: boolean;
    leaveOnEmptyCooldown: number;
    leaveOnEnd: boolean;
    leaveOnEndCooldown: number;
    leaveOnStop: boolean;
    leaveOnStopCooldown: number;
    connectionTimeout: number;
    selfDeaf?: boolean;
    metadata?: Meta | null;
    bufferingTimeout: number;
    noEmitInsert: boolean;
}
interface VoiceConnectConfig {
    deaf?: boolean;
    timeout?: number;
}
interface PostProcessedResult {
    stream: Readable;
    type: StreamType;
}
type OnBeforeCreateStreamHandler = (track: Track, queryType: SearchQueryType, queue: GuildQueue) => Promise<Readable | null>;
type OnAfterCreateStreamHandler = (stream: Readable, queue: GuildQueue) => Promise<PostProcessedResult | null>;
type PlayerTriggeredReason = 'filters' | 'normal';
declare enum GuildQueueEvent {
    /**
     * Emitted when audio track is added to the queue
     */
    audioTrackAdd = "audioTrackadd",
    /**
     * Emitted when audio tracks were added to the queue
     */
    audioTracksAdd = "audioTracksAdd",
    /**
     * Emitted when audio track is removed from the queue
     */
    audioTrackRemove = "audioTrackRemove",
    /**
     * Emitted when audio tracks are removed from the queue
     */
    audioTracksRemove = "audioTracksRemove",
    /**
     * Emitted when a connection is created
     */
    connection = "connection",
    /**
     * Emitted when the bot is disconnected from the channel
     */
    disconnect = "disconnect",
    /**
     * Emitted when the queue sends a debug info
     */
    debug = "debug",
    /**
     * Emitted when the queue encounters error
     */
    error = "error",
    /**
     * Emitted when the voice channel is empty
     */
    emptyChannel = "emptyChannel",
    /**
     * Emitted when the queue is empty
     */
    emptyQueue = "emptyQueue",
    /**
     * Emitted when the audio player starts streaming audio track
     */
    playerStart = "playerStart",
    /**
     * Emitted when the audio player errors while streaming audio track
     */
    playerError = "playerError",
    /**
     * Emitted when the audio player finishes streaming audio track
     */
    playerFinish = "playerFinish",
    /**
     * Emitted when the audio player skips current track
     */
    playerSkip = "playerSkip",
    /**
     * Emitted when the audio player is triggered
     */
    playerTrigger = "playerTrigger",
    /**
     * Emitted when the voice state is updated. Consuming this event may disable default voice state update handler if `Player.isVoiceStateHandlerLocked()` returns `false`.
     */
    voiceStateUpdate = "voiceStateUpdate"
}
interface GuildQueueEvents<Meta = unknown> {
    /**
     * Emitted when audio track is added to the queue
     * @param queue The queue where this event occurred
     * @param track The track
     */
    audioTrackAdd: (queue: GuildQueue<Meta>, track: Track) => unknown;
    /**
     * Emitted when audio tracks were added to the queue
     * @param queue The queue where this event occurred
     * @param tracks The tracks array
     */
    audioTracksAdd: (queue: GuildQueue<Meta>, track: Track[]) => unknown;
    /**
     * Emitted when audio track is removed from the queue
     * @param queue The queue where this event occurred
     * @param track The track
     */
    audioTrackRemove: (queue: GuildQueue<Meta>, track: Track) => unknown;
    /**
     * Emitted when audio tracks are removed from the queue
     * @param queue The queue where this event occurred
     * @param track The track
     */
    audioTracksRemove: (queue: GuildQueue<Meta>, track: Track[]) => unknown;
    /**
     * Emitted when a connection is created
     * @param queue The queue where this event occurred
     */
    connection: (queue: GuildQueue<Meta>) => unknown;
    /**
     * Emitted when the bot is disconnected from the channel
     * @param queue The queue where this event occurred
     */
    disconnect: (queue: GuildQueue<Meta>) => unknown;
    /**
     * Emitted when the queue sends a debug info
     * @param queue The queue where this event occurred
     * @param message The debug message
     */
    debug: (queue: GuildQueue<Meta>, message: string) => unknown;
    /**
     * Emitted when the queue encounters error
     * @param queue The queue where this event occurred
     * @param error The error
     */
    error: (queue: GuildQueue<Meta>, error: Error) => unknown;
    /**
     * Emitted when the voice channel is empty
     * @param queue The queue where this event occurred
     */
    emptyChannel: (queue: GuildQueue<Meta>) => unknown;
    /**
     * Emitted when the queue is empty
     * @param queue The queue where this event occurred
     */
    emptyQueue: (queue: GuildQueue<Meta>) => unknown;
    /**
     * Emitted when the audio player starts streaming audio track
     * @param queue The queue where this event occurred
     * @param track The track that is being streamed
     */
    playerStart: (queue: GuildQueue<Meta>, track: Track) => unknown;
    /**
     * Emitted when the audio player errors while streaming audio track
     * @param queue The queue where this event occurred
     * @param error The error
     * @param track The track that is being streamed
     */
    playerError: (queue: GuildQueue<Meta>, error: Error, track: Track) => unknown;
    /**
     * Emitted when the audio player finishes streaming audio track
     * @param queue The queue where this event occurred
     * @param track The track that was being streamed
     */
    playerFinish: (queue: GuildQueue<Meta>, track: Track) => unknown;
    /**
     * Emitted when the audio player skips current track
     * @param queue The queue where this event occurred
     * @param track The track that was skipped
     */
    playerSkip: (queue: GuildQueue<Meta>, track: Track) => unknown;
    /**
     * Emitted when the audio player is triggered
     * @param queue The queue where this event occurred
     * @param track The track which was played in this event
     */
    playerTrigger: (queue: GuildQueue<Meta>, track: Track, reason: PlayerTriggeredReason) => unknown;
    /**
     * Emitted when the voice state is updated. Consuming this event may disable default voice state update handler if `Player.isVoiceStateHandlerLocked()` returns `false`.
     * @param queue The queue where this event occurred
     * @param oldState The old voice state
     * @param newState The new voice state
     */
    voiceStateUpdate: (queue: GuildQueue<Meta>, oldState: VoiceState, newState: VoiceState) => unknown;
}
declare class GuildQueue<Meta = unknown> {
    #private;
    player: Player;
    options: GuildNodeInit<Meta>;
    private __current;
    tracks: Queue<Track>;
    history: GuildQueueHistory<Meta>;
    dispatcher: StreamDispatcher | null;
    node: GuildQueuePlayerNode<Meta>;
    filters: GuildQueueAudioFilters<Meta>;
    onBeforeCreateStream: OnBeforeCreateStreamHandler;
    onAfterCreateStream: OnAfterCreateStreamHandler;
    repeatMode: QueueRepeatMode;
    timeouts: Collection<string, NodeJS.Timeout>;
    stats: GuildQueueStatistics<Meta>;
    constructor(player: Player, options: GuildNodeInit<Meta>);
    /**
     * Estimated duration of this queue in ms
     */
    get estimatedDuration(): number;
    /**
     * Formatted duration of this queue
     */
    get durationFormatted(): string;
    /**
     * The voice receiver for this queue
     */
    get voiceReceiver(): VoiceReceiverNode | null;
    /**
     * Write a debug message to this queue
     * @param m The message to write
     */
    debug(m: string): void;
    /**
     * The metadata of this queue
     */
    get metadata(): Meta;
    set metadata(m: Meta);
    /**
     * Set metadata for this queue
     * @param m Metadata to set
     */
    setMetadata(m: Meta): void;
    /**
     * Indicates if this queue is currently initializing
     */
    get initializing(): boolean;
    set initializing(v: boolean);
    /**
     * Indicates current track of this queue
     */
    get currentTrack(): Track | null;
    /**
     * Indicates if this queue was deleted previously
     */
    get deleted(): boolean;
    /**
     * The voice channel of this queue
     */
    get channel(): VoiceBasedChannel | null;
    set channel(c: VoiceBasedChannel | null);
    /**
     * The voice connection of this queue
     */
    get connection(): _discordjs_voice.VoiceConnection | null;
    /**
     * The guild this queue belongs to
     */
    get guild(): Guild;
    /**
     * The id of this queue
     */
    get id(): string;
    /**
     * Set transition mode for this queue
     * @param state The state to set
     */
    setTransitioning(state: boolean): void;
    /**
     * if this queue is currently under transition mode
     */
    isTransitioning(): boolean;
    /**
     * Set repeat mode for this queue
     * @param mode The repeat mode to apply
     */
    setRepeatMode(mode: QueueRepeatMode): void;
    /**
     * Gets the size of the queue
     */
    get size(): number;
    /**
     * The size of this queue
     */
    getSize(): number;
    /**
     * Clear this queue
     */
    clear(): void;
    /**
     * Check if this queue has no tracks left in it
     */
    isEmpty(): boolean;
    /**
     * Check if this queue currently holds active audio resource
     */
    isPlaying(): boolean;
    /**
     * Add track to the queue. This will emit `audioTracksAdd` when multiple tracks are added, otherwise `audioTrackAdd`.
     * @param track Track or playlist or array of tracks to add
     */
    addTrack(track: Track | Track[] | Playlist): void;
    /**
     * Remove a track from queue
     * @param track The track to remove
     */
    removeTrack(track: TrackResolvable): Track | null;
    /**
     * Inserts the track to the given index
     * @param track The track to insert
     * @param index The index to insert the track at (defaults to 0)
     */
    insertTrack(track: Track, index?: number): void;
    /**
     * Moves a track in the queue
     * @param from The track to move
     * @param to The position to move to
     */
    moveTrack(track: TrackResolvable, index?: number): void;
    /**
     * Copy a track in the queue
     * @param from The track to clone
     * @param to The position to clone at
     */
    copyTrack(track: TrackResolvable, index?: number): void;
    /**
     * Swap two tracks in the queue
     * @param src The first track to swap
     * @param dest The second track to swap
     */
    swapTracks(src: TrackResolvable, dest: TrackResolvable): void;
    /**
     * Connect to a voice channel
     * @param channelResolvable The voice channel to connect to
     * @param options Join config
     */
    connect(channelResolvable: GuildVoiceChannelResolvable, options?: VoiceConnectConfig): Promise<this>;
    /**
     * The voice connection latency of this queue
     */
    get ping(): number;
    /**
     * Delete this queue
     */
    delete(): void;
    /**
     * Revives this queue
     * @returns
     */
    revive(): void;
    /**
     * Wait for this queue to initialize
     */
    awaitInitialization(): Promise<boolean>;
    /**
     * Set self deaf
     * @param mode On/Off state
     * @param reason Reason
     */
    setSelfDeaf(mode?: boolean, reason?: string): Promise<discord_js.GuildMember>;
    /**
     * Set self mute
     * @param mode On/Off state
     * @param reason Reason
     */
    setSelfMute(mode?: boolean, reason?: string): Promise<discord_js.GuildMember>;
}

interface GuildQueueStatisticsMetadata {
    latency: {
        eventLoop: number;
        voiceConnection: number;
    };
    status: {
        buffering: boolean;
        playing: boolean;
        paused: boolean;
        idle: boolean;
    };
    tracksCount: number;
    historySize: number;
    extractors: number;
    listeners: number;
    memoryUsage: NodeJS.MemoryUsage;
    versions: {
        node: string;
        player: string;
    };
}
declare class GuildQueueStatistics<Meta = unknown> {
    queue: GuildQueue<Meta>;
    constructor(queue: GuildQueue<Meta>);
    /**
     * Generate statistics of this queue
     */
    generate(): GuildQueueStatisticsMetadata;
}

declare class VoiceUtils {
    player: Player;
    cache: Collection<Snowflake, StreamDispatcher>;
    /**
     * The voice utils
     * @private
     */
    constructor(player: Player);
    /**
     * Joins a voice channel, creating basic stream dispatch manager
     * @param {StageChannel|VoiceChannel} channel The voice channel
     * @param {object} [options] Join options
     * @returns {Promise<StreamDispatcher>}
     */
    connect(channel: VoiceChannel | StageChannel, options?: {
        deaf?: boolean;
        maxTime?: number;
        queue: GuildQueue;
    }): Promise<StreamDispatcher>;
    /**
     * Joins a voice channel
     * @param {StageChannel|VoiceChannel} [channel] The voice/stage channel to join
     * @param {object} [options] Join options
     * @returns {VoiceConnection}
     */
    join(channel: VoiceChannel | StageChannel, options?: {
        deaf?: boolean;
        maxTime?: number;
    }): Promise<VoiceConnection>;
    /**
     * Disconnects voice connection
     * @param {VoiceConnection} connection The voice connection
     * @returns {void}
     */
    disconnect(connection: VoiceConnection | StreamDispatcher): void;
    /**
     * Returns Discord Player voice connection
     * @param {Snowflake} guild The guild id
     * @returns {StreamDispatcher}
     */
    getConnection(guild: Snowflake): StreamDispatcher | VoiceConnection | undefined;
}

interface SearchResultData {
    query: string;
    queryType?: SearchQueryType | QueryExtractorSearch | null;
    extractor?: BaseExtractor | null;
    playlist?: Playlist | null;
    tracks?: Track[];
    requestedBy?: User | null;
}
declare class SearchResult {
    player: Player;
    private _data;
    constructor(player: Player, _data: SearchResultData);
    setQueryType(type: SearchQueryType | QueryExtractorSearch): this;
    setRequestedBy(user: User): this;
    setExtractor(extractor: BaseExtractor): this;
    setTracks(tracks: Track[]): this;
    setQuery(query: string): this;
    setPlaylist(playlist: Playlist): this;
    /**
     * The search query
     */
    get query(): string;
    /**
     * The search query type
     */
    get queryType(): SearchQueryType | `ext:${string}`;
    /**
     * The extractor
     */
    get extractor(): BaseExtractor | null;
    /**
     * Playlist result
     */
    get playlist(): Playlist | null | undefined;
    /**
     * Tracks result
     */
    get tracks(): Track[];
    /**
     * Requested by
     */
    get requestedBy(): User | null;
    /**
     * Re-execute this search
     */
    execute(): Promise<SearchResult>;
    /**
     * If this search result is empty
     */
    isEmpty(): boolean;
    /**
     * If this search result has playlist
     */
    hasPlaylist(): boolean;
    /**
     * If this search result has tracks
     */
    hasTracks(): boolean;
    /**
     * JSON representation of this search
     */
    toJSON(): {
        query: string;
        queryType: SearchQueryType | `ext:${string}`;
        playlist: PlaylistJSON | null;
        tracks: TrackJSON[];
        extractor: string | null;
        requestedBy: {} | null;
    };
}

interface QueryCacheOptions {
    checkInterval?: number;
}
declare class QueryCache {
    #private;
    player: Player;
    options: QueryCacheOptions;
    timer: NodeJS.Timer;
    constructor(player: Player, options?: QueryCacheOptions);
    get checkInterval(): number;
    cleanup(): Promise<void>;
    clear(): Promise<void>;
    getData(): Promise<DiscordPlayerQueryResultCache<Track>[]>;
    addData(data: SearchResult): Promise<void>;
    resolve(context: QueryCacheResolverContext): Promise<SearchResult>;
}
declare class DiscordPlayerQueryResultCache<T = unknown> {
    data: T;
    expireAfter: number;
    constructor(data: T, expireAfter?: number);
    hasExpired(): boolean;
}
interface QueryCacheResolverContext {
    query: string;
    requestedBy?: User;
    queryType?: SearchQueryType | `ext:${string}`;
}

interface PlayerNodeInitializationResult<T = unknown> {
    track: Track;
    extractor: BaseExtractor | null;
    searchResult: SearchResult;
    queue: GuildQueue<T>;
}
declare class Player extends PlayerEventsEmitter<PlayerEvents> {
    #private;
    static _singletonKey: symbol;
    readonly id: string;
    readonly client: Client;
    readonly options: PlayerInitOptions;
    nodes: GuildNodeManager<unknown>;
    readonly voiceUtils: VoiceUtils;
    extractors: ExtractorExecutionContext;
    events: PlayerEventsEmitter<GuildQueueEvents<unknown>>;
    /**
     * Creates new Discord Player
     * @param {Client} client The Discord Client
     * @param {PlayerInitOptions} [options] The player init options
     */
    constructor(client: Client, options?: PlayerInitOptions);
    debug(m: string): boolean;
    /**
     * Creates discord-player singleton instance.
     * @param client The client that instantiated player
     * @param options Player initializer options
     */
    static singleton(client: Client, options?: PlayerInitOptions): Player;
    /**
     * Get all active player instances
     */
    static getAllPlayers(): Player[];
    /**
     * Clear all player instances
     */
    static clearAllPlayers(): void;
    /**
     * The current query cache provider
     */
    get queryCache(): QueryCache | null;
    /**
     * Alias to `Player.nodes`
     */
    get queues(): GuildNodeManager<unknown>;
    /**
     * Event loop lag
     * @type {number}
     */
    get eventLoopLag(): number;
    /**
     * Generates statistics
     */
    generateStatistics(): {
        instances: number;
        queuesCount: number;
        queryCacheEnabled: boolean;
        queues: GuildQueueStatisticsMetadata[];
    };
    /**
     * Destroy player
     */
    destroy(): Promise<void>;
    private _handleVoiceState;
    /**
     * Handles voice state update
     * @param {VoiceState} oldState The old voice state
     * @param {VoiceState} newState The new voice state
     * @returns {void}
     */
    handleVoiceState(oldState: VoiceState, newState: VoiceState): void;
    /**
     * Lock voice state handler
     */
    lockVoiceStateHandler(): void;
    /**
     * Unlock voice state handler
     */
    unlockVoiceStateHandler(): void;
    /**
     * Checks if voice state handler is locked
     */
    isVoiceStateHandlerLocked(): boolean;
    /**
     * Initiate audio player
     * @param channel The voice channel on which the music should be played
     * @param query The track or source to play
     * @param options Options for player
     */
    play<T = unknown>(channel: GuildVoiceChannelResolvable, query: string | Track | SearchResult | Track[] | Playlist, options?: SearchOptions & {
        nodeOptions?: GuildNodeCreateOptions<T>;
        connectionOptions?: VoiceConnectConfig;
        afterSearch?: (result: SearchResult) => Promise<SearchResult>;
    }): Promise<PlayerNodeInitializationResult<T>>;
    /**
     * @typedef {object} PlayerSearchResult
     * @property {Playlist} [playlist] The playlist (if any)
     * @property {Track[]} tracks The tracks
     */
    /**
     * Search tracks
     * @param {string | Track | Track[] | Playlist | SearchResult} query The search query
     * @param {SearchOptions} options The search options
     * @returns {Promise<SearchResult>}
     */
    search(query: string | Track | Track[] | Playlist | SearchResult, options?: SearchOptions): Promise<SearchResult>;
    /**
     * Generates a report of the dependencies used by the `@discordjs/voice` module. Useful for debugging.
     * @returns {string}
     */
    scanDeps(): string;
    [Symbol.iterator](): Generator<GuildQueue<unknown>, void, undefined>;
    /**
     * Creates `Playlist` instance
     * @param data The data to initialize a playlist
     */
    createPlaylist(data: PlaylistInitData): Playlist;
}

interface GuildNodeCreateOptions<T = unknown> {
    strategy?: QueueStrategy;
    volume?: number | boolean;
    equalizer?: EqualizerBand[] | boolean;
    a_filter?: PCMFilters[] | boolean;
    biquad?: BiquadFilters | boolean;
    resampler?: number | boolean;
    disableHistory?: boolean;
    skipOnNoStream?: boolean;
    onBeforeCreateStream?: OnBeforeCreateStreamHandler;
    onAfterCreateStream?: OnAfterCreateStreamHandler;
    repeatMode?: QueueRepeatMode;
    leaveOnEmpty?: boolean;
    leaveOnEmptyCooldown?: number;
    leaveOnEnd?: boolean;
    leaveOnEndCooldown?: number;
    leaveOnStop?: boolean;
    leaveOnStopCooldown?: number;
    metadata?: T | null;
    selfDeaf?: boolean;
    connectionTimeout?: number;
    defaultFFmpegFilters?: FiltersName[];
    bufferingTimeout?: number;
    noEmitInsert?: boolean;
}
type NodeResolvable = GuildQueue | GuildResolvable;
declare class GuildNodeManager<Meta = unknown> {
    player: Player;
    cache: Collection<string, GuildQueue<unknown>>;
    constructor(player: Player);
    /**
     * Create guild queue if it does not exist
     * @param guild The guild which will be the owner of the queue
     * @param options Queue initializer options
     */
    create<T = Meta>(guild: GuildResolvable, options?: GuildNodeCreateOptions<T>): GuildQueue<T>;
    /**
     * Get existing queue
     * @param node Queue resolvable
     */
    get<T = Meta>(node: NodeResolvable): GuildQueue<T> | null;
    /**
     * Check if a queue exists
     * @param node Queue resolvable
     */
    has(node: NodeResolvable): boolean;
    /**
     * Delete queue
     * @param node Queue resolvable
     */
    delete(node: NodeResolvable): boolean;
    /**
     * Resolve queue
     * @param node Queue resolvable
     */
    resolve<T = Meta>(node: NodeResolvable): GuildQueue<unknown> | undefined;
    /**
     * Resolve queue id
     * @param node Queue resolvable
     */
    resolveId(node: NodeResolvable): string | null;
}

declare enum ErrorStatusCode {
    STREAM_ERROR = "StreamError",
    AUDIO_PLAYER_ERROR = "AudioPlayerError",
    PLAYER_ERROR = "PlayerError",
    NO_AUDIO_RESOURCE = "NoAudioResource",
    UNKNOWN_GUILD = "UnknownGuild",
    INVALID_ARG_TYPE = "InvalidArgType",
    UNKNOWN_EXTRACTOR = "UnknownExtractor",
    INVALID_EXTRACTOR = "InvalidExtractor",
    INVALID_CHANNEL_TYPE = "InvalidChannelType",
    INVALID_TRACK = "InvalidTrack",
    UNKNOWN_REPEAT_MODE = "UnknownRepeatMode",
    TRACK_NOT_FOUND = "TrackNotFound",
    NO_CONNECTION = "NoConnection",
    DESTROYED_QUEUE = "DestroyedQueue"
}
declare class PlayerError extends Error {
    message: string;
    statusCode: ErrorStatusCode;
    createdAt: Date;
    constructor(message: string, code?: ErrorStatusCode);
    get createdTimestamp(): number;
    valueOf(): ErrorStatusCode;
    toJSON(): {
        stack: string | undefined;
        code: ErrorStatusCode;
        message: string;
        created: number;
    };
    toString(): string | undefined;
}

type FiltersName = keyof QueueFilters;
interface PlayerSearchResult {
    playlist: Playlist | null;
    tracks: Track[];
}
/**
 * @typedef {AudioFilters} QueueFilters
 */
interface QueueFilters {
    bassboost_low?: boolean;
    bassboost?: boolean;
    bassboost_high?: boolean;
    '8D'?: boolean;
    vaporwave?: boolean;
    nightcore?: boolean;
    phaser?: boolean;
    tremolo?: boolean;
    vibrato?: boolean;
    reverse?: boolean;
    treble?: boolean;
    normalizer?: boolean;
    normalizer2?: boolean;
    surrounding?: boolean;
    pulsator?: boolean;
    subboost?: boolean;
    karaoke?: boolean;
    flanger?: boolean;
    gate?: boolean;
    haas?: boolean;
    mcompand?: boolean;
    mono?: boolean;
    mstlr?: boolean;
    mstrr?: boolean;
    compressor?: boolean;
    expander?: boolean;
    softlimiter?: boolean;
    chorus?: boolean;
    chorus2d?: boolean;
    chorus3d?: boolean;
    fadein?: boolean;
    dim?: boolean;
    earrape?: boolean;
    lofi?: boolean;
}
/**
 * The track source:
 * - soundcloud
 * - youtube
 * - spotify
 * - apple_music
 * - arbitrary
 * @typedef {string} TrackSource
 */
type TrackSource = 'soundcloud' | 'youtube' | 'spotify' | 'apple_music' | 'arbitrary';
/**
 * @typedef {object} RawTrackData
 * @property {string} title The title
 * @property {string} description The description
 * @property {string} author The author
 * @property {string} url The url
 * @property {string} thumbnail The thumbnail
 * @property {string} duration The duration
 * @property {number} views The views
 * @property {User} requestedBy The user who requested this track
 * @property {Playlist} [playlist] The playlist
 * @property {TrackSource} [source="arbitrary"] The source
 * @property {any} [engine] The engine
 * @property {boolean} [live] If this track is live
 * @property {any} [raw] The raw data
 */
interface RawTrackData {
    title: string;
    description: string;
    author: string;
    url: string;
    thumbnail: string;
    duration: string;
    views: number;
    requestedBy?: User | null;
    playlist?: Playlist;
    source?: TrackSource;
    engine?: any;
    live?: boolean;
    raw?: any;
    queryType?: SearchQueryType;
}
/**
 * @typedef {object} TimeData
 * @property {number} days Time in days
 * @property {number} hours Time in hours
 * @property {number} minutes Time in minutes
 * @property {number} seconds Time in seconds
 */
interface TimeData {
    days: number;
    hours: number;
    minutes: number;
    seconds: number;
}
/**
 * @typedef {object} PlayerProgressbarOptions
 * @property {boolean} [timecodes] If it should render time codes
 * @property {boolean} [queue] If it should create progress bar for the whole queue
 * @property {number} [length] The bar length
 * @property {string} [line] The bar track
 * @property {string} [indicator] The indicator
 */
interface PlayerProgressbarOptions {
    timecodes?: boolean;
    length?: number;
    line?: string;
    indicator?: string;
    queue?: boolean;
}
/**
 * The search query type
 * This can be one of:
 * - AUTO
 * - YOUTUBE
 * - YOUTUBE_PLAYLIST
 * - SOUNDCLOUD_TRACK
 * - SOUNDCLOUD_PLAYLIST
 * - SOUNDCLOUD
 * - SPOTIFY_SONG
 * - SPOTIFY_ALBUM
 * - SPOTIFY_PLAYLIST
 * - SPOTIFY_SEARCH
 * - FACEBOOK
 * - VIMEO
 * - ARBITRARY
 * - REVERBNATION
 * - YOUTUBE_SEARCH
 * - YOUTUBE_VIDEO
 * - SOUNDCLOUD_SEARCH
 * - APPLE_MUSIC_SONG
 * - APPLE_MUSIC_ALBUM
 * - APPLE_MUSIC_PLAYLIST
 * - APPLE_MUSIC_SEARCH
 * - FILE
 * - AUTO_SEARCH
 * @typedef {string} QueryType
 */
declare const QueryType: {
    readonly AUTO: "auto";
    readonly YOUTUBE: "youtube";
    readonly YOUTUBE_PLAYLIST: "youtubePlaylist";
    readonly SOUNDCLOUD_TRACK: "soundcloudTrack";
    readonly SOUNDCLOUD_PLAYLIST: "soundcloudPlaylist";
    readonly SOUNDCLOUD: "soundcloud";
    readonly SPOTIFY_SONG: "spotifySong";
    readonly SPOTIFY_ALBUM: "spotifyAlbum";
    readonly SPOTIFY_PLAYLIST: "spotifyPlaylist";
    readonly SPOTIFY_SEARCH: "spotifySearch";
    readonly FACEBOOK: "facebook";
    readonly VIMEO: "vimeo";
    readonly ARBITRARY: "arbitrary";
    readonly REVERBNATION: "reverbnation";
    readonly YOUTUBE_SEARCH: "youtubeSearch";
    readonly YOUTUBE_VIDEO: "youtubeVideo";
    readonly SOUNDCLOUD_SEARCH: "soundcloudSearch";
    readonly APPLE_MUSIC_SONG: "appleMusicSong";
    readonly APPLE_MUSIC_ALBUM: "appleMusicAlbum";
    readonly APPLE_MUSIC_PLAYLIST: "appleMusicPlaylist";
    readonly APPLE_MUSIC_SEARCH: "appleMusicSearch";
    readonly FILE: "file";
    readonly AUTO_SEARCH: "autoSearch";
};
type SearchQueryType = keyof typeof QueryType | (typeof QueryType)[keyof typeof QueryType];
interface PlayerEvents {
    debug: (message: string) => any;
    error: (error: Error) => any;
    voiceStateUpdate: (queue: GuildQueue, oldState: VoiceState, newState: VoiceState) => any;
}
declare enum PlayerEvent {
    debug = "debug",
    error = "error",
    voiceStateUpdate = "voiceStateUpdate"
}
/**
 * @typedef {object} PlayOptions
 * @property {boolean} [filtersUpdate=false] If this play was triggered for filters update
 * @property {string[]} [encoderArgs=[]] FFmpeg args passed to encoder
 * @property {number} [seek] Time to seek to before playing
 * @property {boolean} [immediate=false] If it should start playing the provided track immediately
 */
interface PlayOptions {
    filtersUpdate?: boolean;
    encoderArgs?: string[];
    seek?: number;
    immediate?: boolean;
}
type QueryExtractorSearch = `ext:${string}`;
/**
 * @typedef {object} SearchOptions
 * @property {UserResolvable} requestedBy The user who requested this search
 * @property {typeof QueryType|string} [searchEngine='auto'] The query search engine, can be extractor name to target specific one (custom)
 * @property {string[]} [blockExtractors[]] List of the extractors to block
 * @property {boolean} [ignoreCache] If it should ignore query cache lookup
 * @property {SearchQueryType} [fallbackSearchEngine='autoSearch'] Fallback search engine to use
 */
interface SearchOptions {
    requestedBy?: UserResolvable;
    searchEngine?: SearchQueryType | QueryExtractorSearch;
    blockExtractors?: string[];
    ignoreCache?: boolean;
    fallbackSearchEngine?: (typeof QueryType)[keyof typeof QueryType];
}
/**
 * The queue repeat mode. This can be one of:
 * - OFF
 * - TRACK
 * - QUEUE
 * - AUTOPLAY
 * @typedef {number} QueueRepeatMode
 */
declare enum QueueRepeatMode {
    OFF = 0,
    TRACK = 1,
    QUEUE = 2,
    AUTOPLAY = 3
}
/**
 * @typedef {object} PlaylistInitData
 * @property {Track[]} tracks The tracks of this playlist
 * @property {string} title The playlist title
 * @property {string} description The description
 * @property {string} thumbnail The thumbnail
 * @property {album|playlist} type The playlist type: `album` | `playlist`
 * @property {TrackSource} source The playlist source
 * @property {object} author The playlist author
 * @property {string} [author.name] The author name
 * @property {string} [author.url] The author url
 * @property {string} id The playlist id
 * @property {string} url The playlist url
 * @property {any} [rawPlaylist] The raw playlist data
 */
interface PlaylistInitData {
    tracks: Track[];
    title: string;
    description: string;
    thumbnail: string;
    type: 'album' | 'playlist';
    source: TrackSource;
    author: {
        name: string;
        url: string;
    };
    id: string;
    url: string;
    rawPlaylist?: any;
}
/**
 * @typedef {object} TrackJSON
 * @property {string} title The track title
 * @property {string} description The track description
 * @property {string} author The author
 * @property {string} url The url
 * @property {string} thumbnail The thumbnail
 * @property {string} duration The duration
 * @property {number} durationMS The duration in ms
 * @property {number} views The views count
 * @property {Snowflake} requestedBy The id of the user who requested this track
 * @property {PlaylistJSON} [playlist] The playlist info (if any)
 */
interface TrackJSON {
    id: Snowflake;
    title: string;
    description: string;
    author: string;
    url: string;
    thumbnail: string;
    duration: string;
    durationMS: number;
    views: number;
    requestedBy: Snowflake;
    playlist?: PlaylistJSON;
}
/**
 * @typedef {object} PlaylistJSON
 * @property {string} id The playlist id
 * @property {string} url The playlist url
 * @property {string} title The playlist title
 * @property {string} description The playlist description
 * @property {string} thumbnail The thumbnail
 * @property {album|playlist} type The playlist type: `album` | `playlist`
 * @property {TrackSource} source The track source
 * @property {object} author The playlist author
 * @property {string} [author.name] The author name
 * @property {string} [author.url] The author url
 * @property {TrackJSON[]} tracks The tracks data (if any)
 */
interface PlaylistJSON {
    id: string;
    url: string;
    title: string;
    description: string;
    thumbnail: string;
    type: 'album' | 'playlist';
    source: TrackSource;
    author: {
        name: string;
        url: string;
    };
    tracks: TrackJSON[];
}
/**
 * @typedef {object} PlayerInitOptions
 * @property {boolean} [autoRegisterExtractor=true] If it should automatically register `@discord-player/extractor`
 * @property {YTDLDownloadOptions} [ytdlOptions] The options passed to `ytdl-core`
 * @property {number} [connectionTimeout=20000] The voice connection timeout
 * @property {boolean} [smoothVolume=true] Toggle smooth volume transition
 * @property {boolean} [lagMonitor=30000] Time in ms to re-monitor event loop lag
 * @property {boolean} [lockVoiceStateHandler] Prevent voice state handler from being overridden
 * @property {string[]} [blockExtractors] List of extractors to disable querying metadata from
 * @property {string[]} [blockStreamFrom] List of extractors to disable streaming from
 * @property {QueryCache | null} [queryCache] Query cache provider
 * @property {boolean} [ignoreInstance] Ignore player instance
 */
interface PlayerInitOptions {
    autoRegisterExtractor?: boolean;
    ytdlOptions?: downloadOptions;
    connectionTimeout?: number;
    smoothVolume?: boolean;
    lagMonitor?: number;
    lockVoiceStateHandler?: boolean;
    blockExtractors?: string[];
    blockStreamFrom?: string[];
    queryCache?: QueryCache | null;
    ignoreInstance?: boolean;
}

declare class AudioFilters {
    constructor();
    static filters: Record<FiltersName, string>;
    static get<K extends FiltersName>(name: K): Record<keyof QueueFilters, string>[K];
    static has<K extends FiltersName>(name: K): boolean;
    static [Symbol.iterator](): IterableIterator<{
        name: FiltersName;
        value: string;
    }>;
    static get names(): (keyof QueueFilters)[];
    static get length(): number;
    static toString(): string;
    /**
     * Create ffmpeg args from the specified filters name
     * @param filter The filter name
     * @returns
     */
    static create<K extends FiltersName>(filters?: K[]): string;
    /**
     * Defines audio filter
     * @param filterName The name of the filter
     * @param value The ffmpeg args
     */
    static define(filterName: string, value: string): void;
    /**
     * Defines multiple audio filters
     * @param filtersArray Array of filters containing the filter name and ffmpeg args
     */
    static defineBulk(filtersArray: {
        name: string;
        value: string;
    }[]): void;
}

declare class Util {
    /**
     * Utils
     */
    private constructor();
    /**
     * Creates duration string
     * @param {object} durObj The duration object
     * @returns {string}
     */
    static durationString(durObj: Record<string, number>): string;
    /**
     * Parses milliseconds to consumable time object
     * @param {number} milliseconds The time in ms
     * @returns {TimeData}
     */
    static parseMS(milliseconds: number): TimeData;
    /**
     * Builds time code
     * @param {TimeData} duration The duration object
     * @returns {string}
     */
    static buildTimeCode(duration: TimeData): string;
    /**
     * Picks last item of the given array
     * @param {any[]} arr The array
     * @returns {any}
     */
    static last<T = any>(arr: T[]): T;
    /**
     * Checks if the voice channel is empty
     * @param {VoiceChannel|StageChannel} channel The voice channel
     * @returns {boolean}
     */
    static isVoiceEmpty(channel: VoiceChannel | StageChannel): boolean;
    /**
     * Safer require
     * @param {string} id Node require id
     * @returns {any}
     */
    static require(id: string): {
        module: any;
        error: null;
    } | {
        module: null;
        error: unknown;
    };
    static import(id: string): Promise<{
        module: any;
        error: null;
    } | {
        module: null;
        error: unknown;
    }>;
    /**
     * Asynchronous timeout
     * @param {number} time The time in ms to wait
     * @returns {Promise<unknown>}
     */
    static wait(time: number): Promise<undefined>;
    static noop(): void;
    static getFetch(): Promise<any>;
    static warn(message: string, code?: string, detail?: string): void;
    static randomChoice<T>(src: T[]): T;
}

declare class TypeUtil {
    private constructor();
    static isFunction(t: unknown): t is Function;
    static isNumber(t: unknown): t is number;
    static isString(t: unknown): t is string;
    static isBoolean(t: unknown): t is boolean;
    static isNullish(t: unknown): t is null | undefined;
    static isArray(t: unknown): t is unknown[];
}

declare class QueryResolver {
    /**
     * Query resolver
     */
    private constructor();
    static get regex(): {
        spotifyAlbumRegex: RegExp;
        spotifyPlaylistRegex: RegExp;
        spotifySongRegex: RegExp;
        vimeoRegex: RegExp;
        reverbnationRegex: RegExp;
        attachmentRegex: RegExp;
        appleMusicAlbumRegex: RegExp;
        appleMusicPlaylistRegex: RegExp;
        appleMusicSongRegex: RegExp;
    };
    /**
     * Resolves the given search query
     * @param {string} query The query
     * @returns {QueryType}
     */
    static resolve(query: string, fallbackSearchEngine?: (typeof QueryType)[keyof typeof QueryType]): (typeof QueryType)[keyof typeof QueryType];
    /**
     * Parses vimeo id from url
     * @param {string} query The query
     * @returns {string}
     */
    static getVimeoID(query: string): string | null | undefined;
    static validateId(q: string): boolean;
    static validateURL(q: string): boolean;
}

declare function useHistory<Meta = unknown>(node: NodeResolvable): GuildQueueHistory<Meta> | null;

declare function usePlayer<Meta = unknown>(node: NodeResolvable): GuildQueuePlayerNode<Meta> | null;

declare function useQueue<Meta = unknown>(node: NodeResolvable): GuildQueue<Meta> | null;

declare function useMasterPlayer(): Player | null;

declare function useMetadata<T = unknown>(node: NodeResolvable): readonly [() => T, (metadata: T | null) => void];

interface TimelineDispatcherOptions {
    ignoreFilters: boolean;
}
declare function useTimeline(node: NodeResolvable, options?: Partial<TimelineDispatcherOptions>): {
    readonly timestamp: PlayerTimestamp;
    readonly volume: number;
    readonly paused: boolean;
    pause(): boolean;
    resume(): boolean;
    setVolume(vol: number): boolean;
    setPosition(time: number): Promise<boolean>;
} | null;

declare function onAfterCreateStream(handler: OnAfterCreateStreamHandler): void;

declare function onBeforeCreateStream(handler: OnBeforeCreateStreamHandler): void;

declare const version: string;

export { AFilterGraph, AudioFilters, BaseExtractor, DiscordPlayerQueryResultCache, EqualizerConfigurationPreset, ErrorStatusCode, ExtractorExecutionContext, ExtractorExecutionEvents, ExtractorExecutionFN, ExtractorExecutionResult, ExtractorInfo, ExtractorSearchContext, FFMPEG_ARGS_PIPED, FFMPEG_ARGS_STRING, FFMPEG_SRATE_REGEX, FFmpegFilterer, FFmpegStreamOptions, FilterGraph, FiltersName, GuildNodeCreateOptions, GuildNodeInit, GuildNodeManager, GuildQueue, GuildQueueAFiltersCache, GuildQueueAudioFilters, GuildQueueEvent, GuildQueueEvents, GuildQueueHistory, GuildQueuePlayerNode, NextFunction, NodeResolvable, OnAfterCreateStreamHandler, OnBeforeCreateStreamHandler, PlayOptions, Player, PlayerError, PlayerEvent, PlayerEvents, PlayerEventsEmitter, PlayerInitOptions, PlayerNodeInitializationResult, PlayerProgressbarOptions, PlayerSearchResult, PlayerTimestamp, PlayerTriggeredReason, Playlist, PlaylistInitData, PlaylistJSON, PostProcessedResult, QueryCache, QueryCacheOptions, QueryCacheResolverContext, QueryExtractorSearch, QueryResolver, QueryType, QueueFilters, QueueRepeatMode, RawTrackData, RawTrackInit, ResourcePlayOptions, SearchOptions, SearchQueryType, SearchResult, SearchResultData, StreamDispatcher, TimeData, TimelineDispatcherOptions, Track, TrackJSON, TrackResolvable, TrackSource, TypeUtil, Util, VoiceConnectConfig, VoiceEvents, VoiceReceiverNode, VoiceReceiverOptions, VoiceUtils, createFFmpegStream, onAfterCreateStream, onBeforeCreateStream, useHistory, useMasterPlayer, useMetadata, usePlayer, useQueue, useTimeline, version };
