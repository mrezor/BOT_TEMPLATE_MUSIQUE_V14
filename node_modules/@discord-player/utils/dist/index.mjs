var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// src/Collection.ts
import { Collection as CollectionNative } from "@discordjs/collection";
var _array;
var Collection = class extends CollectionNative {
  constructor() {
    super(...arguments);
    __privateAdd(this, _array, void 0);
  }
  array() {
    if (__privateGet(this, _array))
      return __privateGet(this, _array);
    __privateSet(this, _array, [...this.values()]);
    return __privateGet(this, _array);
  }
  set(key, value) {
    __privateSet(this, _array, null);
    super.set(key, value);
    return this;
  }
  delete(key) {
    __privateSet(this, _array, null);
    return super.delete(key);
  }
};
__name(Collection, "Collection");
_array = new WeakMap();

// src/Queue.ts
import { inspect } from "util";
var Queue = class {
  constructor(strategy = "FIFO", initializer = []) {
    this.strategy = strategy;
    if (!["FIFO", "LIFO"].includes(strategy))
      throw new TypeError(`Invalid queue strategy "${strategy}"!`);
    this.store = Array.isArray(initializer) ? initializer : [];
    Object.defineProperty(this, "store", {
      writable: true,
      configurable: true,
      enumerable: false
    });
  }
  get data() {
    return this.toArray();
  }
  static from(data, strategy = "FIFO") {
    return new Queue(strategy, data);
  }
  isFIFO() {
    return this.strategy === "FIFO";
  }
  isLIFO() {
    return this.strategy === "LIFO";
  }
  add(item) {
    if (this.strategy === "FIFO") {
      if (Array.isArray(item)) {
        this.store.push(...item);
      } else {
        this.store.push(item);
      }
    } else {
      if (Array.isArray(item)) {
        this.store.unshift(...item);
      } else {
        this.store.unshift(item);
      }
    }
  }
  clear() {
    this.store = [];
  }
  shuffle() {
    for (let i = this.store.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this.store[i], this.store[j]] = [this.store[j], this.store[i]];
    }
  }
  remove(itemFilter) {
    const items = this.store.filter(itemFilter);
    if (items.length)
      this.store = this.store.filter((res) => !items.includes(res));
  }
  removeOne(itemFilter) {
    const item = this.store.find(itemFilter);
    if (item)
      this.store = this.store.filter((res) => res !== item);
  }
  find(itemFilter) {
    return this.store.find(itemFilter);
  }
  filter(itemFilter) {
    return this.store.filter(itemFilter);
  }
  some(itemFilter) {
    return this.store.some(itemFilter);
  }
  every(itemFilter) {
    return this.store.every(itemFilter);
  }
  map(itemFilter) {
    const arr = this.toArray();
    return arr.map(itemFilter);
  }
  at(idx) {
    const arr = this.toArray();
    return typeof Array.prototype.at === "function" ? arr.at(idx) : arr[idx];
  }
  dispatch() {
    return this.store.shift();
  }
  clone() {
    return new Queue(this.strategy, this.store.slice());
  }
  get size() {
    return this.store.length;
  }
  toString() {
    return `Queue<${this.store.length} items>`;
  }
  toArray() {
    return this.store.slice();
  }
  toJSON() {
    return this.store;
  }
  [inspect.custom]() {
    return `${this.constructor.name} {
  strategy: '${this.strategy}',
  data: ${inspect(this.data, {
      showHidden: false,
      colors: true,
      depth: 1,
      maxArrayLength: 5
    })}
}`;
  }
};
__name(Queue, "Queue");

// src/EventEmitter.ts
import { EventEmitter } from "node:events";

// src/utils.ts
function createEnum(data) {
  const obj = {};
  for (const item of data)
    obj[item] = item;
  return Object.freeze(obj);
}
__name(createEnum, "createEnum");

// src/Errors.ts
var PlayerException = class extends Error {
  constructor(message) {
    super(typeof message === "string" ? message : JSON.stringify(message, null, 2));
  }
};
__name(PlayerException, "PlayerException");

// src/index.ts
var version = "0.2.1";
export {
  Collection,
  EventEmitter,
  PlayerException,
  Queue,
  createEnum,
  createEnum as keyMirror,
  version
};
//# sourceMappingURL=index.mjs.map